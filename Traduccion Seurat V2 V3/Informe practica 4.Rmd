---
title: "Informe práctica 4 - Constructing Single Cell Trajectories with Monocle3"
author: "Adam Casas"
date: 'Compilado: `r format(Sys.Date(), "%d de %B del %Y")`'
output: 
  html_document:
    df_print: paged
    highlight: kate
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_float: yes
---

```{r configuracion_inicial, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = F,
                      warning = F,
                      tidy = F)
set.seed(1)
##################################################
#######        Encoded in UTF-8        ###########
##################################################
```

***

# Introducción

En esta práctica usaremos los mismos datos que empleamos en la práctica 1, o sea el dataset de SC3-seq (un tipo de scRNA-seq) del desarrollo embrionario en _Macaca fascicularis_ (Nakamura et al., 2016). Usaremos el protocolo de Monocle sobre estos datos para inferir la trayectoria del desarrollo embrionario.

Las células cambian de un estado funcional a otro en respuesta a estímulos, durante patologías o a lo largo del desarrollo vital del individuo. Cada estado funcional expresa un conjunto de genes concretos, lo que dota a la célula en cuestión un repertorio de proteínas y metabolitos específicos para llevar a cabo la tarea para la cual esté diseñado el estado en cuestión. 

No obstante, cuando una célula transiciona de un estado a otro, esta sufre una reconfiguración transcripcional gradual, con genes que se silencian y genes que se activan. Purificar células en transformación puede resultar difícil, lo que dificulta la caracterización de dichos estados transitorios. Por suerte, este problema no lo tenemos con scRNA-seq, dado que no es necesario purificar poblaciones celulares.


***

<br>

# El protocolo de Monocle 3

El protocolo de Monocle consta de 5 pasos principales, detallados a continuación:

![Protocolo de Monocle. Sacado de [Trapnell _et al._ (2014)](http://cole-trapnell-lab.github.io/monocle-release/monocle3/)](./Cosas accesorias Informe 4/monocle.png)


## Paso 1: Preprocesamiento y normalizado de los datos


Primero Monocle normaliza los valores de expresión génica para controlar la varianza técnica debida a la profundidad del secuenciado y la recuperación del ARN de la muestra.


## Paso 2: Reducir la dimensionalidad de los datos


Luego se proyectan las células al espacio del PCA (por defecto se calculan las 50 1<sup>as</sup> componentes) para eliminar ruido y facilitar la computación de los siguientes pasos. Tras esto, y de manera optativa, puedes reducir la dimensionalidad más aún con t-SNE o UMAP. Sea como sea, después de la reducción de la dimensionalidad Monocle puede aplicar un clustering a las células, inferir la trayectoria, o hacer ambas.


## Paso 3: Clustering y particionado de las células

Monocle 3 puede aprender múltiples trayectorias desconectadas, lo cual es importante dado que muchos experimentos capturan una comunidad de células que estén respondiendo a un estímulo o diferenciándose, y cada célula puede responder de una manera u otra.


Monocle 2 asume que todos tus datos son parte de una única trayectoria, por lo que para construir varias trayectorias individuales, se tendría que dividir manualmente cada grupo de células, generar datasets de manera acorde y ejecutar Monocle 2 sobre cada dataset. Por otro lado, Monocle 3 puede detectar que algunas células forman parte de un proceso biológico distinto y generar acordemente varias trayectorias en paralelo, sin tener que manipular y dividir el dataset como sería el caso con Monocle 2. Monocle 3 consigue esto particionando las células en supergrupos usando un método derivado del AGA o _Approximate Graph Abstraction_ ([Wolf _et al._, 2019](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1663-x)). Células de supergrupos distintos no pueden ser parte de la misma trayectoria.


## Paso 4: Generar el grafo principal

Monocle 3 dispone de 3 maneras distintas de organizarlas las células en trayectorias, todas ellas basadas en el concepto de embebimiento en grafo reverso o "_reversed graph embedding_". __DDRTree__ es el método usado por Monocle 2 para generar trayectorias con forma de árbol, y este algoritmo ha sido mejorado en Monocle 3. En concreto, se ha optimizado su rendimiento, lo que le permite procesar millones de células en minutos. __SimplePPT__ genera también trayectorias en forma de árbol, pero a diferencia de DDRTree, no aplica reducciones de la dimensionalidad adicionales. __L1Graph__ es un algoritmo de optimización avanzado capaz de generar trayectorias que incluyan bucles.

Una vez que Monocle ha aprendido un grafo principal que se ajusta a los datos, se proyecta cada célula al susodicho grafo. A continuación el usuario selecciona uno o más puntos en el grafo que definan los puntos de partida de la trayectoria. Monocle define entonces el pseudotiempo como la distancia de cada célula al punto de inicio más cercano.


## Paso 5: Análisis de expresión diferencial y visualización

Por último, detectamos biomarcadores específicos de cada clúster celular, genes con expresión cambiante a lo largo de la trayectoria y graficamos los resultados.

Monocle 3 provides a suite of regression tests to find genes that differ between clusters and over trajectories. Monocle 3 also introduces a new test that uses the principal graph directly and can help find genes that vary in complex ways over a trajectory with loops and more intricate structures.


***

<br>


# Cargamos Monocle y los datos crudos desde el objeto `seurat`


```{r, eval = F, echo = F}
# Instalación de Monocle 3 V1.0.0
BiocManager::install(c('BiocGenerics', 'DelayedArray', 'DelayedMatrixStats',
                       'limma', 'S4Vectors', 'SingleCellExperiment',
                       'SummarizedExperiment', 'batchelor', 'Matrix.utils'))
install.packages("devtools")
devtools::install_github('cole-trapnell-lab/leidenbase')
devtools::install_github('cole-trapnell-lab/monocle3')

# Si usas R 3.6, instala spatstat 1.64-1, ya que R 3.6 no es compatible con
# versiones posteriores de spatstat
install.packages("https://cran.r-project.org/src/contrib/Archive/spatstat/spatstat_1.64-1.tar.gz", repo=NULL, type="source")
```



```{r, warning = F}
# Cargamos librerías
library(monocle3)
library(reticulate)
library(Seurat)

# Importamos el dataset de Seurat 3 a Monocle  
data <- readRDS(file = "./Cosas accesorias Informe 1/nakamura_P4.rds")
head(data@meta.data)


# Creamos un nuevo objeto CellDataSet a partir del objeto seurat. Nótese que
# tenemos que añadir la columna "gene_short_name" dado que varios métodos de
# Monocle 3 lo usan por ejemplo, plot_cells(c3, genes = "ZNF692")

data@assays$RNA@meta.features$gene_short_name <-  rownames(data@assays$RNA@meta.features)

c3 <- new_cell_data_set(expression_data = data@assays$RNA@counts,
                        cell_metadata = data@meta.data,
                        gene_metadata = data@assays$RNA@meta.features)

# Vemos los nombres de las columnas de los metadatos del objeto seurat
colnames(pData(c3))

# Accedemos a la columna Cell.Identity para ver a qué tejido pertenecen las células
pData(c3)$Cell.Identity

# Alternativamente:
# c3$Cell.Identity
```


***

<br>

# Paso 1: Preprocesamiento y normalizado de los datos

We then estimate size factors for each cell and dispersion function for the genes in _c3_ . Monocle 3 now performs these operations using the _DelayedArray_ packages so they work on datasets with millions of cells. The dispersion calculation and several other operations rely on the DelayedArray package in Bioconductor, which splits the operation into blocks in order to avoid exhausting the computer's memory. You can control the block size and the verbosity of these operations as shown below:

```{r, warning = F, eval = F}
# Pass TRUE if you want to see progress output on some of Monocle 3's operations

DelayedArray:::set_verbose_block_processing(TRUE)

# Passing a higher value will make some computations faster but use more memory. Adjust with caution!
options(DelayedArray.block.size=1000e1)

c3 <- estimateSizeFactors(c3)

c3 <- estimateDispersions(c3)
```

Next, run the preprocessCDS() function to project the data onto the top principal components:

```{r}
# function to project the data onto the top principal components:
c3 <- preprocess_cds(c3, method = "PCA", num_dim = 20,
                     norm_method = "log")

plot_pc_variance_explained(c3)
```


***

<br>


# Paso 2: Reducir la dimensionalidad de los datos

Then, apply a further round of (nonlinear) dimensionality reduction using UMAP:

```{r, warning = F}
c3 <- reduce_dimension(c3, preprocess_method = "PCA", 
                       reduction_method = "UMAP",
                       umap.fast_sgd = F,
                       cores = 1) # umap.fast_sgd = F y cores = 1 para reproducibilidad

plot_cells(c3, color_cells_by = "Cell.Identity")

plot_cells(c3, genes = "ZNF692")
```



# Paso 3: Partición de las células en supergrupos

Rather than forcing all cells into a single developmental trajectory, Monocle 3 enables you to learn a set of trajectories that describe the biological process you're studying. For example, if you're looking at a community of immune cells responding to infection, each cell type will respond to antigen (and each other) in a different way, so they should be organized into distinct trajectories. This can also be helpful when you have small groups of outlier cells that for either technical or biological reasons are very dissimilar from the rest of the cells in your experiment. They can confuse a trajectory analysis. Monocle 3's partitioning strategy circumvents this issue because such groups often wind up in their own partition. In the Paul data, there is a small outgroup the authors classified as dendritic cells that Monocle automatically partitions away from the main trajectory.

In Monocle 3, we recognize "disjoint" trajectories by drawing on ideas from Alex Wolf and colleagues, who recently introduced the concept of abstract graph participation [@Wolf208819]. Monocle 3 implements the test for cell community connectedness from Wolf et al. via the partitionCells() function, which divides the cells into "supergroups".


```{r}
c3 <- cluster_cells(c3, reduction_method = "UMAP",
                    verbose = T)
```

***

<br>

# Paso 4: Aprender el grafo principal

Now that the cells are partitioned, we can organize each supergroup into a separate trajectory. The default method for doing this in Monocle 3 is _SimplePPT_, which assumes that each trajectory is a tree (albeit one that may have multiple roots). Here we will use _DDRTree_ for the reasons mentioned above. Learn these trees with the learnGraph function:

```{r}
c3 <- learn_graph(c3, use_partition = T,
                  close_loop = T, verbose = T)

# c3 <- order_cells(c3, reduction_method = "UMAP", verbose = T) Mirar luego

plot_cells(c3)


# With graph autocorrelation:
#pr_test_res <- graph_test(c3,  neighbor_graph="principal_graph", cores=4)
#pr_deg_ids <- row.names(subset(pr_test_res, q_value < 0.05))
```


***

<br>

# Paso 5: Visualizar la trayectoria

Once the you've learned the trajectory, you can visualize the it:

```{r, fig.width=7, fig.height=8, eval = F}
cell_type_color <- c("EXMC" = "blue",
                      "Gast"  = "#46C7EF",
                      "PostL-EPI" = "magenta",
                      "Hypoblast" = "red",
                      "ICM" = "darkgreen",
                      "PreE-TE" = "#4EB859",
                      "Post-paTE" = "#EFAD1E",
                      "PostE-EPI" = "gold",
                      "Pre-EPI" = "gray",
                      "PreL-TE" = "black",
                      "VEYE" = 'purple' )

p1 <- plot_cell_trajectory(c3, color_by = "res.0.6") +
  scale_color_manual(values = cell_type_color)

p1
```

**Exercise 4.1 What do you think about the trajectory? Is it in agreement with previous biological knowledge? **


**Adjusting the start of pseudotime with orderCells**

We know that ICM (inner cell mass) will give rise to the pre-implantation epiblast and the hypoblast. We need to tell Monocle that these cells are the "beginning" of the trajectory. In Monocle 2, this wouldn't be possible, because the software required that the root be one of the leaves of the tree. Monocle 3 allows you to specify an internal part of the tree as the root. 


```{r, fig.width=5, fig.height=5.5, eval = F}
icm_node_ids = get_correct_root_state(c3,
                                      cell_phenotype =
                                        'res.0.6', "ICM")
c3 <- orderCells(c3, root_pr_nodes = icm_node_ids)
plot_cell_trajectory(c3)
```


***

<br>

# Identifying genes that vary in expression over a trajectory

We are often interested in finding genes that are differentially expressed across a single-cell trajectory. Monocle 3 introduces a new approach for finding such genes that draws on a powerful technique in spatial correlation analysis, the Moran’s I test. Moran’s I is a measure of multi-directional and multi-dimensional spatial autocorrelation. The statistic tells you whether cells at nearby positions on a trajectory will have similar (or dissimilar) expression levels for the gene being tested. Although both Pearson correlation and Moran’s I ranges from -1 to 1, the interpretation of Moran’s I is slightly different: +1 means that nearby cells will have perfectly similar expression (as in the right panel below); 0 represents no correlation (center), and -1 means that neighboring cells will be *anti-correlated* (left).

```{r monocle.figure2, out.width = '90%', fig.cap="Moran’s I test example.", echo=FALSE}
knitr::include_graphics("./Cosas accesorias Informe 4/moran.png")
```



```{r, warning=FALSE, results='hide', echo=TRUE, eval =F}
#Identifying genes that vary in expression over a trajectory  (Moran's I test)
pr_graph_test <- principalGraphTest(c3, k=25, cores=1, 
                                    interactive = FALSE, verbose = FALSE)
```

We can easily view the top differentially expressed genes as follows:

```{r, fig.width=5, fig.height=5.5, eval = F}
# 'pr_graph_test' returns a data frame containing the p values and q-values 
# from the Moran's I test on the parallel arrays of models
head(pr_graph_test )
dim(pr_graph_test )
X <- dplyr::add_rownames(pr_graph_test) %>%
  dplyr::arrange(plyr::desc(morans_test_statistic), plyr::desc(-qval)) # %>% head(30)
```

Once you've identified differentially expressed genes, you'll often want to visualize their expression levels on the trajectory. The plots below show the top 2 most differentially expressed genes along the trajectory.

```{r, fig.width=5, fig.height=5.5, eval = F}
Y <- as.data.frame(X)
# DE genes over the whole trajectory:
sig <- nrow(subset(pr_graph_test, qval < 0.01))

plot_cell_trajectory(c3, markers=Y$gene_short_name[1] , 
                     use_color_gradient = TRUE, alpha=0.7)
plot_cell_trajectory(c3, markers=Y$gene_short_name[2] , 
                     use_color_gradient = TRUE, alpha=0.7)
```




**Exercise 4.2 Repeat the analysis using UMAP instead of t-SNE dimensionality reduction. **




***

<br>

# Bibliografía

* Wolf, F.A., Hamey, F.K., Plass, M. et al. PAGA: graph abstraction reconciles clustering with trajectory inference through a topology preserving map of single cells. Genome Biol 20, 59 (2019). https://doi.org/10.1186/s13059-019-1663-x


***

<br>

# sessionInfo()

<details>

<summary> __Click para mostrar__ </summary>

```{r, echo = F}
sessionInfo()
```

</details>