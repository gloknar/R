---
title: "Informe práctica 4 - Constructing Single Cell Trajectories with Monocle3"
author: "Adam Casas"
date: 'Compilado: `r format(Sys.Date(), "%d de %B del %Y")`'
output: 
  html_document:
    df_print: paged
    highlight: kate
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_float: yes
---

```{r configuracion_inicial, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = F,
                      warning = F,
                      tidy = F)
set.seed(1)
##################################################
#######        Encoded in UTF-8        ###########
##################################################
```

***

# Introducción

En esta práctica usaremos los mismos datos que los de la práctica 1, o sea el dataset de SC3-seq (un tipo de scRNA-seq) del desarrollo embrionario en _Macaca fascicularis_ ([Nakamura _et al._, 2016](https://www.nature.com/articles/nature19096)). En esta ocasión, en lugar de usar TSCAN u ouija, usaremos Monocle sobre estos datos para inferir la trayectoria del desarrollo embrionario.

Las células cambian de un estado funcional a otro en respuesta a estímulos, durante patologías o a lo largo del desarrollo vital del individuo. Cada estado funcional expresa un conjunto de genes concretos, lo que dota a la célula en cuestión un repertorio de proteínas y metabolitos específicos para llevar a cabo la tarea para la cual esté diseñado el estado en cuestión. 

No obstante, cuando una célula transiciona de un estado a otro, esta sufre una reconfiguración transcripcional gradual, con genes que se silencian y genes que se activan. Purificar células en transformación puede resultar difícil, lo que dificulta la caracterización de dichos estados transitorios. Por suerte, este problema no lo tenemos con scRNA-seq, dado que no es necesario purificar poblaciones celulares.


***

<br>

# Esquema del protocolo de Monocle 3

<br>

El protocolo de Monocle consta de 5 pasos principales, detallados a continuación:

![Protocolo de Monocle. Sacado de [Trapnell _et al._ (2014)](http://cole-trapnell-lab.github.io/monocle-release/monocle3/)](./Cosas accesorias Informe 4/monocle.png)


<br>

## Paso 1: Preprocesamiento y normalizado de los datos


Primero Monocle normaliza los valores de expresión génica para controlar la varianza técnica debida a la profundidad del secuenciado y la recuperación del ARN de la muestra.



<br>

## Paso 2: Reducir la dimensionalidad de los datos

Luego se proyectan las células al espacio del PCA (por defecto se calculan las 50 1<sup>as</sup> componentes) para eliminar ruido y facilitar la computación de los siguientes pasos. Tras esto, y de manera optativa, puedes reducir la dimensionalidad más aún con t-SNE o UMAP. Sea como sea, después de la reducción de la dimensionalidad Monocle puede aplicar un clustering a las células, inferir la trayectoria, o hacer ambas.


<br>

## Paso 3: Clustering y particionado de las células


Monocle 3 puede aprender múltiples trayectorias desconectadas, lo cual es importante dado que muchos experimentos capturan una comunidad de células que estén respondiendo a un estímulo o diferenciándose, y cada célula puede responder de una manera u otra.


Monocle 2 asume que todos tus datos son parte de una única trayectoria, por lo que para construir varias trayectorias individuales, se tendría que dividir manualmente cada grupo de células, generar datasets de manera acorde y ejecutar Monocle 2 sobre cada dataset. Por otro lado, Monocle 3 puede detectar que algunas células forman parte de un proceso biológico distinto y generar acordemente varias trayectorias en paralelo, sin tener que manipular y dividir el dataset como sería el caso con Monocle 2. Monocle 3 consigue esto particionando las células en supergrupos usando un método derivado del AGA o _Approximate Graph Abstraction_ ([Wolf _et al._, 2019](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1663-x)). Células de supergrupos distintos no pueden ser parte de la misma trayectoria.


<br>

## Paso 4: Generar el grafo principal


Monocle 3 dispone de 3 maneras distintas de organizarlas las células en trayectorias, todas ellas basadas en el concepto de embebimiento en grafo reverso o "_reversed graph embedding_". __DDRTree__ es el método usado por Monocle 2 para generar trayectorias con forma de árbol, y este algoritmo ha sido mejorado en Monocle 3. En concreto, se ha optimizado su rendimiento, lo que le permite procesar millones de células en minutos. __SimplePPT__ genera también trayectorias en forma de árbol, pero a diferencia de DDRTree, no aplica reducciones de la dimensionalidad adicionales. __L1Graph__ es un algoritmo de optimización avanzado capaz de generar trayectorias que incluyan bucles.

Una vez que Monocle ha aprendido un grafo principal que se ajusta a los datos, se proyecta cada célula al susodicho grafo. A continuación el usuario selecciona uno o más puntos en el grafo que definan los puntos de partida de la trayectoria. Monocle define entonces el pseudotiempo como la distancia de cada célula al punto de inicio más cercano.


<br>


## Paso 5: Análisis de expresión diferencial y visualización

Por último, detectamos biomarcadores específicos de cada clúster celular, genes con expresión cambiante a lo largo de la trayectoria y graficamos los resultados.

Monocle 3 provee una suite de tests estadísticos de regresión para detectar genes que difieren entre clusters y a lo largo de las trayectorias. Además, Monocle 3 incluye un novedoso test que usa el grafo principal directamente y permite detectar genes cuyas expresiones varían de manera compleja a lo largo de trayectorias con bucles y estructuras más complicadas.


***

<br>


# El protocolo de Monocle 3 en la práctica 


Antes de nada debemos asegurarnos de tener instalados tanto `Seurat 3` como `Monocle3 1.0.0`. A continuación se proporciona un chunk de código para instalar dichos paquetes. Este chunk no se ejecutará en la compilación de este informe, dado que sendos paquetes ya se encuentran instalados en mi máquina. 

```{r, eval = F}
# Instalación de Monocle 3 V1.0.0
BiocManager::install(c('BiocGenerics', 'DelayedArray', 'DelayedMatrixStats',
                       'limma', 'S4Vectors', 'SingleCellExperiment',
                       'SummarizedExperiment', 'batchelor', 'Matrix.utils'))
install.packages("devtools")
devtools::install_github('cole-trapnell-lab/leidenbase')
devtools::install_github('cole-trapnell-lab/monocle3')

# Si usas R 3.6, instala spatstat 1.64-1, ya que R 3.6 no es compatible con
# versiones posteriores de spatstat
install.packages("https://cran.r-project.org/src/contrib/Archive/spatstat/spatstat_1.64-1.tar.gz", 
                 repo=NULL, type="source")
```


```{r, echo = F}
print(paste("Seurat version", packageVersion("Seurat"), "is installed", sep = " "))
cat("\n")
print(paste0("Monocle 3 version ", packageVersion("monocle3"), " is installed as well", sep = ""))
```


<br>

Hecho eso, procedemos a cargar las librerías de interés y cargar los datos:

```{r, warning = F}
# Cargamos librerías
library(monocle3)
library(reticulate)
library(Seurat)
library(ggplot2)

# Cargamos en memoria el objeto seurat de la práctica 1  
data <- readRDS(file = "./Cosas accesorias Informe 1/nakamura_P4.rds")
head(data@meta.data)

# Creamos un nuevo objeto CellDataSet a partir del objeto seurat. Nótese que
# tenemos que añadir la columna "gene_short_name" dado que varios métodos de
# Monocle 3 lo usan, como por ejemplo plot_cells(c3, genes = "ZNF692")
gene.annotation <- data.frame(gene_short_name = rownames(data@assays$RNA@meta.features), 
           row.names = rownames(data@assays$RNA@meta.features))

head(gene.annotation)

# data[["RNA"]]@meta.features$gene_short_name <-  rownames(data@assays$RNA@meta.features)

c3 <- new_cell_data_set(expression_data = data@assays$RNA@counts,
                        cell_metadata = data@meta.data,
                        gene_metadata = gene.annotation) # gene_metadata = data@assays$RNA@meta.features
```


<br>

Para los objetos de tipo `CellDataSet`, podemos acceder a su información con los métodos `pData()`, `fData()` y `exprs()` de Monocle 3 (nótese que al crear un nuevo objeto `CellDataSet`, Monocle 3 ha calculado automáticamente el `Size_Factor` de las células, pues esa columna no la generamos en la práctica 1 y por tanto no ha aparecido al examinar el bolsillo `@meta.data` de nuestro objeto `seurat`):

```{r}
# Vemos los metadatos de las células
head(pData(c3))

# Accedemos a la columna Cell.Identity para ver a qué tejido pertenecen las
# células
head(pData(c3)$Cell.Identity)

# Alternativamente:
# c3$Cell.Identity

# Ídem para los metadatos de los genes con fData:
colnames(fData(c3))
head(fData(c3))

# Visualizamos una parte de la matriz de conteos
exprs(c3)[1:5,1:5]
```



<br>

## Paso 1: Preprocesamiento y normalizado de los datos


En el preprocesamiento y normalizado de datos se suele proceder a estimar el factor de tamaño de las muestras y la dispersión (=varianza) de la expresión de los genes. Monocle 3 realiza estas y otras operaciones con el paquete `DelayedArray`, lo que le permite escalar con millones de células. Dicho paquete divide las operaciones en bloques para prevenir el consumo excesivo de RAM del ordenador. Puedes controlar el tamaño de cada bloque y los mensajes que se devuelven por consola con los siguientes comandos:

> Nota: Puesto que la estimación del factor de tamaño de las muestras se realiza automáticamente al generar un nuevo objeto `CellDataSet`, podríamos incluir el siguiente chunk de código antes de la carga de datos, pero en aras de mantener un orden, lo incluiremos aquí. Si tienes experiencia trabajando con Monocle 3, puedes correr este chunk antes de generar el susodicho objeto.

```{r, echo = F, eval = F}
# http://hartleys.github.io/JunctionSeq/Rhtml/estimateJunctionSeqSizeFactors.html
# Explicación de size factors
```


```{r}
# Selecciona TRUE para ver en consola el progreso de algunas operaciones de
# Monocle 3
DelayedArray:::set_verbose_block_processing(TRUE)

# Tamaño de cada bloque, en bytes (es 1e8 bytes = 95.37MBs por defecto). A mayor
# tamaño del bloque, más rápidas serán algunos cálculos pero usará más memoria
# RAM, así que ajústalo con cautela.
DelayedArray::getAutoBlockSize()
DelayedArray::setAutoBlockSize(1e9)

# Alternativamente:
# getOption("DelayedArray.block.size")
# options(DelayedArray.block.size=1e9)
```


Establecido el tamaño de bloque y los mensajes por consola, procedemos al normalizado de los datos con el comando `preprocess_cds`. Nótese que se recomienda usar el método PCA para datos de RNA-seq y LSI para datos de ATAC-seq.

```{r}
c3 <- preprocess_cds(c3, method = "PCA", num_dim = 20,
                     norm_method = "log")

plot_pc_variance_explained(c3)
```


<br>


## Paso 2: Reducir la dimensionalidad de los datos

Ahora procedemos a computar la proyección de los datos en un espacio de dimensionalidad reducida (la proyección por defecto en Monocle 3 1.0.0 es UMAP, pero también podemos calcular el t-SNE, PCA, LSI o Aligned) con el comando `reduce_dimension()`. Tras calcular la proyección, podemos visualizarla con el comando `plot_cells()`. 

Nótese que si calculamos el UMAP, podemos acelerar su computación modificando los parámetros `umap.fast_sgd` y `cores`, pero hacer esto incurre en que cada vez que calculemos el UMAP, generaremos proyecciones ligeramente distintas, aunque sólo hayamos modificado uno de los 2 parámetros mentados. Esto puede ser aceptable según la situación, pero por motivos de reproducibilidad de este informe, optaremos por no modificar ninguno de esos 2 parámetros Por fortuna, el dataset de Nakamura _et al._ es relativamente pequeño, por lo que no notaremos mucho la diferencia.


```{r, message = F}
c3 <- reduce_dimension(c3, preprocess_method = "PCA", 
                       reduction_method = "UMAP",
                       umap.fast_sgd = F,
                       cores = 1)

plot_cells(c3, color_cells_by = "Cell.Identity", 
           group_label_size = 3, norm_method = "log") + 
  ggtitle("Tejidos embrionarios (UMAP)") + 
  theme(plot.title = element_text(hjust = 0.5))


# Biomarcador de early epiblast, expresado en tejidos Pre-EPI y PostE-EPI 
plot_cells(c3, genes = "GBX2", color_cells_by = "Cell.Identity",  group_label_size = 3, 
           norm_method = "log", cell_size = 1) +
  ggtitle("Expresión de GBX2, biomarcador del epiblasto temprano (UMAP)") +
  theme(plot.title = element_text(hjust = .5))


# Biomarcador del hipoblasto 
plot_cells(c3, genes = "GATA6", color_cells_by = "Cell.Identity", group_label_size = 3, 
           norm_method = "log", cell_size = 1) +
  ggtitle("Expresión de GATA6, biomarcador del hipoblasto (UMAP)") +
  theme(plot.title = element_text(hjust = .5))
```

```{r, echo = F, eval = F}
# Mas biomarcadores: https://discovery.lifemapsc.com/in-vivo-development/inner-cell-mass/inner-cell-mass
```



<br>

## Paso 3: Partición de las células en supergrupos


En vez de forzar a todas las células en una única trayectoria, Monocle 3 permite inferir un conjunto de trayectorias, de manera que te permite estudiar varios procesos biológicos simultáneos con un mismo dataset. Por ejemplo, durante una infección (ya sea vírica, bacteriana, fúngica...), el sistema inmune responde a varios estímulos (antígenos, citocinas, superantígenos...), por lo que cada célula inmune ejercerá un rol determinado. Por ende, dicho proceso se caracteriza mejor por un conjunto de trayectorias, en lugar de una única trayectoria.

Otra ventaja de inferir más de una trayectoria es que el algoritmo se vuelve resistente a la presencia de células extremas o _outliers_, las cuales normalmente confundirían a la trayectoria original. Al particionar las células en supergrupos, Monocle 3 agrupa entre sí dichas células extremas y las diferencia de otros supergrupos.

En Monocle 3, las trayectorias independientes o disjuntas (_disjoint_)

In Monocle 3, we recognize "disjoint" trajectories by drawing on ideas from Alex Wolf and colleagues, who recently introduced the concept of abstract graph participation [@Wolf208819]. Monocle 3 implements the test for cell community connectedness from Wolf et al. via the partitionCells() function, which divides the cells into "supergroups".


```{r}
c3 <- cluster_cells(c3, reduction_method = "UMAP",
                    verbose = T)

plot_cells(c3, color_cells_by = "partition")
```


<br>

## Paso 4: Aprender el grafo principal

Now that the cells are partitioned, we can organize each supergroup into a separate trajectory. The default method for doing this in Monocle 3 is _SimplePPT_, which assumes that each trajectory is a tree (albeit one that may have multiple roots). Here we will use _DDRTree_ for the reasons mentioned above. Learn these trees with the learnGraph function:

```{r}
c3 <- learn_graph(c3, use_partition = T,
                  close_loop = T, verbose = T)

# c3 <- order_cells(c3, reduction_method = "UMAP", verbose = T) Mirar luego

plot_cells(c3)
# With regression:
# 
# gene_fits <- fit_models(c3, model_formula_str = "~Cell.Identity")
# fit_coefs <- coefficient_table(gene_fits)
# emb_time_terms <- fit_coefs %>% filter(term == "Cell.Identity")
# emb_time_terms <- emb_time_terms %>% mutate(q_value = p.adjust(p_value))
# sig_genes <- emb_time_terms %>% filter (q_value < 0.05) %>% pull(gene_short_name)

# With graph autocorrelation:
#pr_test_res <- graph_test(c3,  neighbor_graph="principal_graph", cores=4)
#pr_deg_ids <- row.names(subset(pr_test_res, q_value < 0.05))
```



<br>

## Paso 5: Visualizar la trayectoria

Once the you've learned the trajectory, you can visualize the it:

```{r, fig.width=7, fig.height=8, eval = F}
cell_type_color <- c("EXMC" = "blue",
                      "Gast"  = "#46C7EF",
                      "PostL-EPI" = "magenta",
                      "Hypoblast" = "red",
                      "ICM" = "darkgreen",
                      "PreE-TE" = "#4EB859",
                      "Post-paTE" = "#EFAD1E",
                      "PostE-EPI" = "gold",
                      "Pre-EPI" = "gray",
                      "PreL-TE" = "black",
                      "VEYE" = 'purple' )

p1 <- plot_cell_trajectory(c3, color_by = "res.0.6") +
  scale_color_manual(values = cell_type_color)

p1
```

**Exercise 4.1 What do you think about the trajectory? Is it in agreement with previous biological knowledge? **


**Adjusting the start of pseudotime with orderCells**

We know that ICM (inner cell mass) will give rise to the pre-implantation epiblast and the hypoblast. We need to tell Monocle that these cells are the "beginning" of the trajectory. In Monocle 2, this wouldn't be possible, because the software required that the root be one of the leaves of the tree. Monocle 3 allows you to specify an internal part of the tree as the root. 


```{r, fig.width=5, fig.height=5.5, eval = F}
icm_node_ids = get_correct_root_state(c3,
                                      cell_phenotype =
                                        'res.0.6', "ICM")
c3 <- orderCells(c3, root_pr_nodes = icm_node_ids)
plot_cell_trajectory(c3)
```


***

<br>

# Identifying genes that vary in expression over a trajectory

We are often interested in finding genes that are differentially expressed across a single-cell trajectory. Monocle 3 introduces a new approach for finding such genes that draws on a powerful technique in spatial correlation analysis, the Moran’s I test. Moran’s I is a measure of multi-directional and multi-dimensional spatial autocorrelation. The statistic tells you whether cells at nearby positions on a trajectory will have similar (or dissimilar) expression levels for the gene being tested. Although both Pearson correlation and Moran’s I ranges from -1 to 1, the interpretation of Moran’s I is slightly different: +1 means that nearby cells will have perfectly similar expression (as in the right panel below); 0 represents no correlation (center), and -1 means that neighboring cells will be *anti-correlated* (left).

```{r monocle.figure2, out.width = '90%', fig.cap="Moran’s I test example.", echo=FALSE}
knitr::include_graphics("./Cosas accesorias Informe 4/moran.png")
```



```{r, warning=FALSE, results='hide', echo=TRUE, eval =F}
#Identifying genes that vary in expression over a trajectory  (Moran's I test)
pr_graph_test <- principalGraphTest(c3, k=25, cores=1, 
                                    interactive = FALSE, verbose = FALSE)
```

We can easily view the top differentially expressed genes as follows:

```{r, fig.width=5, fig.height=5.5, eval = F}
# 'pr_graph_test' returns a data frame containing the p values and q-values 
# from the Moran's I test on the parallel arrays of models
head(pr_graph_test )
dim(pr_graph_test )
X <- dplyr::add_rownames(pr_graph_test) %>%
  dplyr::arrange(plyr::desc(morans_test_statistic), plyr::desc(-qval)) # %>% head(30)
```

Once you've identified differentially expressed genes, you'll often want to visualize their expression levels on the trajectory. The plots below show the top 2 most differentially expressed genes along the trajectory.

```{r, fig.width=5, fig.height=5.5, eval = F}
Y <- as.data.frame(X)
# DE genes over the whole trajectory:
sig <- nrow(subset(pr_graph_test, qval < 0.01))

plot_cell_trajectory(c3, markers=Y$gene_short_name[1] , 
                     use_color_gradient = TRUE, alpha=0.7)
plot_cell_trajectory(c3, markers=Y$gene_short_name[2] , 
                     use_color_gradient = TRUE, alpha=0.7)
```




**Exercise 4.2 Repeat the analysis using UMAP instead of t-SNE dimensionality reduction. **




***

<br>

# Bibliografía

* Nakamura, T., Okamoto, I., Sasaki, K., Yabuta, Y., Iwatani, C., Tsuchiya, H., Seita, Y., Nakamura, S., Yamamoto, T., and Saitou, M. (2016). A developmental coordinate of pluripotency among mice, monkeys and humans. Nature, 537(7618):57–62.

* Wolf, F.A., Hamey, F.K., Plass, M. et al. PAGA: graph abstraction reconciles clustering with trajectory inference through a topology preserving map of single cells. Genome Biol 20, 59 (2019). https://doi.org/10.1186/s13059-019-1663-x


***

<br>

# sessionInfo()

<details>

<summary> __Click para mostrar__ </summary>

```{r, echo = F}
sessionInfo()
```

</details>