---
title: "Informe práctica 3"
author: "Adam Casas"
date: 'Compilado: `r format(Sys.Date(), "%d de %B del %Y")`'
output: 
  html_document:
    df_print: paged
    highlight: kate
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_float: yes
---

```{r configuracion_inicial, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = F,
                      warning = F,
                      tidy = F)
##################################################
#######        Encoded in UTF-8        ###########
##################################################
```

***

# Integración de datasets de distintas especies con Análisis de Correlación Canónica (CCA)


Integrar datasets en Seurat V2 era tedioso, pues había que ejecutar varias líneas de código para obtener los resultados deseados. La 3ª versión de Seurat simplificó enormemente el protocolo con la aparición de los comandos `FindIntegrationAnchors()` y `IntegrateData`, pues ejecutan automáticamente la retahíla de pasos necesarios en Seurat V2.

Dicho esto, usaremos para este informe 2 datasets de scRNA-seq provenientes del trabajo de [Butler _et al._](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6700744/) (2018). Los datasets en cuestión consisten en tejido pancreático de humano y de ratón, respectivamente. Aplicaremos el análisis de correlación canónica (CCA) para integrar sendos datasets.


<br>

***

# Carga y preprocesado de los datasets humano y murino

Primero cargamos las matrices de conteos de los datasets de interés:

```{r}
set.seed(1)

human.data <- read.table("./Archivos accesorios/Codigo y datos de las Practicas 1-4/data/pancreas_human.expressionMatrix.txt", sep = "\t")

mouse.data <- read.table("./Archivos accesorios/Codigo y datos de las Practicas 1-4/data/pancreas_mouse.expressionMatrix.txt", sep = "\t")
```


<br>

A continuación creamos dos objetos `seurat` a partir de dichas matrices de conteos y añadimos a sus metadatos la columna `species`, donde se recoge la información sobre la especie de la que provienen los datos. Nótese que las matrices de conteo de Butler _et al._ ya tienen filtradas las células mal secuenciadas, por lo que podemos omitir el paso del filtrado de células.

Por tanto el siguiente paso a realizar sería el normalizado, escalado de datos y detección de genes diferencialmente expresados, pero dado que el comando `FindIntegrationAnchors` integra las funciones de escalado y detección de genes altamente variables, no es necesario hacerlo ahora, aunque sería una buena práctica hacerlo (por tanto dejaremos las funciones `ScaleData` y `FindVariableFeatures` comentadas en el siguiente chunk).

Téngase en cuenta que de acuerdo al paper de [Stuart _et al._, 2019](https://doi.org/10.1016/j.cell.2019.05.031 ), las células ancla o _anchors_ son pares de células de distintos datasets que presentan perfiles de expresión génica similares y por tanto son vecinas mutuas o _mutual nearest neighbours_. 

```{r}
library(Seurat)
# Seurat V3.2 no es compatible con la ultima version de spatstat (2.0-1). Puedes
# instalar la versión previa con el siguiente comando:
#
# devtools::install_version(package = "spatstat", version = "1.64-1")


# Objeto seurat del dataset humano
human <- CreateSeuratObject(counts = human.data)
human@meta.data$species <- "human"
human <- NormalizeData(human)
# human <- ScaleData(human)
# human <- FindVariableFeatures(human, selection.method = "vst")


# Objeto seurat del dataset murino
mouse <- CreateSeuratObject(counts = mouse.data)
mouse@meta.data$species <- "mouse"
mouse <- NormalizeData(mouse)
# mouse <- ScaleData(mouse)
# mouse <- FindVariableFeatures(mouse, selection.method = "vst")
```

<br>

***

# Integración con CCA 

Con los datasets ya cargados, procedemos a integrarlos en un único objeto seurat denominado `pancreas.integrated`. Para integrar los datasets, usaremos el ya mencionado comando `FindIntegrationAnchors`, el cual acepta como input una lista nombrada de los objetos seurat a integrar. Nótese que en el parámetro `normalization.method` hay que indicar el algoritmo empleado para el normalizado de los datos en el paso previo (este puede ser el método `LogNormalize` o el método `SCT`).

La función `FindIntegrationAnchors` realiza una reducción de la dimensionalidad y busca en dicha proyección las _anchors_ de los datasets que se le pasen como input. Las técnicas de reducción de la dimensionalidad que incluye este comando son el CCA y el RPCA ( _Reciprocal PCA_). De acuerdo al [laboratorio Satija](https://satijalab.org/seurat/archive/v3.2/integration.html), el CCA es apto para integrar datasets de distintas especies, pero no es computacionalmente eficiente para datasets grandes, por lo que si se quiere integrar datasets grandes y de una misma especie, se recomienda usar en su lugar el RPCA.

```{r}
# Lista nombrada de los objetos seurat a integrar
pancreas.list <- list(human, mouse)
names(pancreas.list) <- c("human", "mouse")

# Buscamos las anchors de ambos datasets y realizamos el CCA con 20 componentes
# canónicas
pancreas.anchors <- FindIntegrationAnchors(object.list = pancreas.list, scale = T, 
                                           normalization.method = "LogNormalize", 
                                           reduction = "cca", 
                                           dims = 1:20)

# Integramos ambos datasets en uno nuevo
pancreas.integrated <- IntegrateData(anchorset = pancreas.anchors, 
                                     new.assay.name = "integrated", 
                                     normalization.method = "LogNormalize", 
                                     dims = 1:20)
```

Con los datasets ya integrados en un único objeto `seurat`, basta con escalar los datos y ya podemos emplear dicho objeto en nuestros protocolos de visualizado y clustering.

```{r}
# Cargamos librerías gráficas
library(ggplot2)


# Escalamos el dataset integrado para emplearlo en protocolos posteriores
pancreas.integrated <- ScaleData(pancreas.integrated, verbose = T)


# Con el dataset ya escalado, podemos calcular y visualizar las células en las
# distintas proyecciones disponibles en Seurat
pancreas.integrated <- RunPCA(pancreas.integrated, npcs = 20, verbose = T)
pancreas.integrated <- RunTSNE(pancreas.integrated, reduction = "pca", dims = 1:20)
pancreas.integrated <- RunUMAP(pancreas.integrated, reduction = "pca", dims = 1:20)


# Gráficos
DimPlot(pancreas.integrated, reduction = "pca", group.by = "species") +
  ggtitle("PCA (20 componentes canónicas)") + theme(plot.title = element_text(hjust = 0.5))

DimPlot(pancreas.integrated, reduction = "tsne", group.by = "species") +
  ggtitle("t-SNE (20 componentes canónicas)") + theme(plot.title = element_text(hjust = 0.5))

DimPlot(pancreas.integrated, reduction = "umap", group.by = "species") +
  ggtitle("UMAP (20 componentes canónicas)") + theme(plot.title = element_text(hjust = 0.5))
```

<br>

***

# Clustering

Ahora encontramos clusters de células como haríamos en un protocolo cualquiera de scRNA-seq. Dado que tenemos muchas células en el dataset integrado, y por motivos de eficiencia computacional, vamos a usar el método `igraph` en el comando `FindClusters` en lugar del método por defecto `matrix`:

```{r}
# Encontramos clusters
pancreas.integrated <- FindNeighbors(pancreas.integrated, dims = 1:20)
pancreas.integrated <- FindClusters(pancreas.integrated, resolution = 1, method = "igraph", algorithm = 1)

# Visualizamos los clusters
DimPlot(pancreas.integrated, reduction = "tsne", label = T, group.by = "seurat_clusters") +
  ggtitle("t-SNE (20 componentes canónicas)") + theme(plot.title = element_text(hjust = 0.5))

DimPlot(pancreas.integrated, reduction = "umap", label = T, group.by = "seurat_clusters") +
  ggtitle("UMAP (20 componentes canónicas)") + theme(plot.title = element_text(hjust = 0.5))
```

<br>

***

# Ejercicios


<details>
<summary> __Ejercicio 3.1: Las células β de los islotes de Langerhans producen insulina (¿¿y las alfa y las Delta??). ¿Puedes identificar dichas células en el dataset?__ </summary>


<br>

__Solución:__


Pedro Madrigal nos recomienda aquí buscar aquellas células que expresan el gen arquitecto [PDX1](https://www.genecards.org/cgi-bin/carddisp.pl?gene=PDX1#function), el cual codifica para un factor de transcripción de los genes de la insulina y la somatostatina (entre otros) y que participa en la organogénesis del páncreas. No obstante, si en su lugar buscamos el propio gen de la insulina, __INS__, podremos mejorar la resolución del gráfico (pues es específico de las células $\beta$ y se expresa en mayor cantidad que PDX1, pues los genes que codifican para factores de transcripción suelen tener niveles bajos de expresión).



```{r}
# Nota sobre `FeaturePlot`:
# Seurat V2 usa los parámetros `reduction.use`, `features.plot` y `cols.use`;
# Seurat V3 usa los parámetros `reduction`, `features` y `cols`, respectivamente


# Usamos el factor de transcripción PDX1. Al ser un TF, usamos un "min.cutoff"
# pequeño:
FeaturePlot(pancreas.integrated, reduction ='umap', features = "PDX1", 
            min.cutoff = "q10", cols = c("lightgrey", "blue"), pt.size = 0.5)


# Usamos la insulina. Al tener mayor expresión que un TF, usamos un "min.cutoff"
# mayor:
FeaturePlot(pancreas.integrated, reduction ='umap', features = "INS2", 
            min.cutoff = "q60", cols = c("lightgrey", "blue"), pt.size = 0.5)
```


```{r, fig.width = 8}
# Adicionalmente, podemos usar el factor de transcripción expecífico de células
# beta MAFA:
FeaturePlot(pancreas.integrated, reduction ='umap', features = c("INS2"), 
            min.cutoff = "q10", cols = c("lightgrey", "blue"), pt.size = 0.5, 
            split.by = "species")
```


<br>

En vista de los resultados obtenidos, parece ser que las células de los clusters 2, 5, 7, 8 y 10 (grupo central derecho en la proyección del UMAP) corresponden a las células pancreáticas $\beta$. Podemos validar estas conclusiones con los metadatos proporcionados por el estudio original:

```{r}
# The exact tSNE and clusters can vary slightly, below we load in the output from the manuscript
pancreas.metadata <- read.table("./Archivos accesorios/Codigo y datos de las Practicas 1-4/data/Supplementary_Table_PancreasCellData.tsv", sep = "\t", skip = 2, header = T, row.names = 1)

pancreas.integrated <- AddMetaData(pancreas.integrated, metadata = pancreas.metadata)


DimPlot(pancreas.integrated, group.by = "Cluster_ID", label = T, reduction = "tsne")
DimPlot(pancreas.integrated, group.by = "Cluster_ID", label = T, reduction = "umap", pt.size = 0.3)
```

```{r}
cluster5.markers <- FindMarkers(pancreas.integrated, ident.1 = 5, min.pct = 0.25, only.pos = T)
head(cluster5.markers)
cluster5.markers
which(rownames(cluster5.markers) == "PDX1")
```


</details>


<br>






<details>
<summary> __Ejercicio 3.2: Can you identify gene markers that are unique in the cluster of Pancreatic β cells?__ </summary>

<br>

__Solución:__






```{r, eval = F}
FeaturePlot(pancreas.integrated, reduction ='umap', features = c("REG1A", "PPY", "SST", "GHRL", "VWF", "SOX10"), 
            min.cutoff = "q9", cols = c("lightgrey", "blue"), pt.size = 0.5)
```



</details>


<br>





<details>
<summary> __Ejercicio 3.3: Can you identify genes that are differentially expressed between Pancreatic β cells and pancreatic α cells?__ </summary>

<br>

__Solución:__


</details>




<br>

***

# sessionInfo()

<details>

<summary> Click para mostrar </summary>

```{r, echo = F}
sessionInfo()
```

</details>
