---
title: "Informe práctica 2"
author: "Adam Casas"
date: 'Compilado: `r format(Sys.Date(), "%d de %B del %Y")`'
output: 
  html_document:
    df_print: paged
    highlight: kate
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_float: yes
---

```{r configuracion_inicial, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = TRUE,
                      warning = FALSE,
                      tidy = F)
##################################################
#######        Encoded in UTF-8        ###########
##################################################
```

***

# Introducción al pseudotiempo

__El pseudotiempo es el ordenamiento basado en la similaridad de las células a lo largo de la trayectoria de un proceso de desarrollo contínuo.__



El pseudotiempo es una medida de cuánto progreso ha hecho una célula en un proceso biológico como por ejemplo la diferenciación celular. En muchos procesos biológicos, las células no progresan en perfecta sincronía. En estudios de expresión de single-cell sobre procesos tales como la diferenciación celular, las células estudiadas pueden mostrar diversos grados de desarrollo. Es decir, en una población de células capturadas exactamente a la vez, algunas células pueden estar más desarrolladas, mientras que otras pueden ni haber empezado el proceso en cuestión. Esta asincronía dificulta seriamente el estudio de la secuencia de cambios regulatorios que ocurren cuando las células transicionan de un estado a otro. Seguirle la pista a la expresión en todas las células capturadas a la vez produce un sentido muy comprimido de la cinética de un gen, y la variabilidad aparente de la expresión de ese gen será muy elevada. Al ordenar cada célula de acuerdo a su progreso a lo largo de una trayectoria aprendida, el análisis del pseudotiempo alivia los problemas derivados de la susodicha asincronía. En lugar de rastrear los cambios de la expresión génica en función del tiempo, diversas herramientas rastrean dichos cambios en función del progreso a lo largo de la trayectoria, la cual denominamos "pseudotiempo". El pseudotiempo es una unidad abstracta de progreso: en realidad es la distancia entre una célula dada y el comienzo de la trayectoria, medida a lo largo del camino más corto. La longitud total de la trayectoria se define en términos de la cantidad total de cambios transcripcionales que sufre una célula mientras se mueve del estado inicial al final.

```{r, message = F}
library("SingleCellExperiment")
library("TSCAN")
library("destiny")
library("SLICER")
library("ouija")
library("scater")
library("ggplot2")
library("ggthemes")
library("ggbeeswarm")
library("corrplot")
# library("M3Drop")
# library("monocle)
set.seed(1)
```


En muchas situaciones, uno estudia un proceso en el cual las células cambian continuamente. Esto incluye, por ejemplo, muchos procesos de diferenciación que tienen lugar durante el desarrollo del organismo: tras un estímulo, las células cambian de un tipo a otro. Idealmente, nos interesaría monitorizar los niveles de expresión de una célula dada a lo largo del tiempo. Desafortunadamente, tal monitorización no es posible en scRNA-seq dado que la célula se lisa cuando el ARN se extrae.



En su lugar, debemos muestrear en múltiples puntos del tiempo y así obtener "fotografías" de los perfiles de expresión génicos. Puesto que algunas células se diferenciarán más rápido que otras, cada fotografía puede contener células en diversas etapas del desarrollo. __Usamos métodos estadísticos para ordenar las células a lo largo de una o más trayectorias las cuales representan las trayectorias del desarrollo subyacentes, este ordenamiento se conoce como "pseudotiempo".__


En esta práctica nos centraremos en 4 herramientas para ordenar las células según su grado de desarrollo en el pseudotiempo: TSCAN, SLICER, destiny y ouija. Para ilustrar su uso, emplearemos el dataset del desarrollo embrionario en ratón de [Deng _et al._, 2014](https://science.sciencemag.org/content/343/6167/193). Dicho dataset cuenta con 268 células provenientes de la fase temprana del desarrollo embrional y extraídas en 10 puntos de tiempo. En este caso no hace falta alinear las células a la trayectoria del pseudotiempo dado que están ya etiquetadas con información sobre la trayectoria embrionaria. Por tanto, las etiquetas son la _ground truth_ o verdad experimental sobre la cual podemos comparar el rendimiento obtenido por los susodichos métodos.

Una revisión más o menos reciente de [Cannoodt _et al._](https://onlinelibrary.wiley.com/doi/full/10.1002/eji.201646347) publicada en 2016 nos aporta un resumen detallado de los distintos algoritmos empleados para la inferencia de trayectoria en scRNA-seq. Dicha revisión cubre:


* **Monocle** - Paquete de Bioconductor

* **TSCAN** - Paquete de Bioconductor

* **SLICER** - Paquete de R, disponible sólo a través de GitHub

* Waterfall - Paquete de R (se incluye un script en el suplemento del artículo original de [Shin _et al,_ 2015](https://www.cell.com/cell-stem-cell/fulltext/S1934-5909(15)00312-4) y en los [archivos asociados](https://github.com/gloknar/R-Utilities/tree/master/Traduccion%20Seurat%20V2%20V3/Cosas%20accesorias%20Informe%202) a este informe)

* Mpath - Paquete de R disponible en GitHub (comprimido con formato `tar.gz`). La función está documentada, pero el workflow no, ni tiene una _vignette_.

* Wishbone - Paquete de Python

* SCUBA - Paquete de Matlab

* Wanderlust - Paquete de Matlab

* SCOUP - Programa en C++ por línea de comandos 

<br>

Las figuras 1 y 2 del paper de Cannoodt _et al._ resumen algunas de las características de estos métodos.


![Figura 1. Descripción de los diversos métodos de inferencia de trayectoria para datos de scRNA-seq (Figura 2 de Cannoodt _et al._, 2016).](./Cosas Accesorias Informe 2/fig2.png)

<br>

![Figura 2. Caracterización de los métodos de inferencia de trayectoria para scRNA-seq (Figura 3 de Cannoodt _et al._, 2016).](./Cosas Accesorias Informe 2/fig3.png)


***

<br>

# Visualización del dataset


Al igual que el dataset de Nakamura _et al._ usado en la práctica 1, el dataset de Deng _et al._ contiene células embrionarias en los primeros estadios de Carnegie, solo que en este caso las células son de ratón, y no de macaco cangrejero. El dataset de esta práctica se encuentra en el archivo `deng-reads.rds`.


```{r}
# Leemos los datos
deng_SCE <- readRDS(file = "./Archivos accesorios/Codigo y datos de las Practicas 1-4/data/deng-reads.rds")

# Reordenamos los niveles, ya que zigoto < 2 células < 4 células, etc...
deng_SCE$cell_type2 <- factor(deng_SCE$cell_type2, 
                              levels = c("zy", "early2cell", "mid2cell", "late2cell",
                              "4cell", "8cell", "16cell", "earlyblast", "midblast", 
                              "lateblast")) 


# Generamos y formateamos una matriz de conteos crudos (i.e. nº de transcritos
# por gen y célula)
deng <- counts(deng_SCE)

# Establecemos el nombre de las células en el objeto `cellLabels`
cellLabels <- deng_SCE$cell_type2
colnames(deng) <- cellLabels
```


Tal como muestra el siguiente gráfico, el PCA muestra bastante bien la estructura de los datos y los separa correctamente en su mayoría, exceptuando aquellas células que corresponden al estadio de blastocisto (early/mid/lateblast), que están mezcladas entre sí. Se aprecia cómo las células están ordenadas en el espacio del PCA en sentido horario, desde la etapa de zigoto (zy) hasta la de blastocisto tardío (lateblast).

```{r}
# Corremos PCA en un objeto de tipo SingleCellExperiment
deng_SCE <- runPCA(deng_SCE)

# Graficamos el PCA
BiocGenerics::plotPCA(deng_SCE, colour_by = "cell_type2") + 
  ggtitle("PCA de células embrionarias de ratón") + 
  theme(plot.title = element_text(hjust = 0.5))
```

Aquí el PCA nos proporciona un útil punto de referencia para comprobar diversos métodos de inferencia de trayectoria. A diferencia del t-SNE y el UMAP, el PCA podría revelarnos mejor el tiempo de desarrollo, a expensas de producir un clustering peor. Un algoritmo muy sencillo de inferencia podría ser simplemente utilizar las coordenadas en el espacio del PCA de la primera componente principal. 


```{r}
deng_SCE$PC1 <- reducedDim(x = deng_SCE, type = "PCA")[,1]

# Graficamos el pseudotiempo según las coordenadas de la primera componente
# principal
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = PC1, y = cell_type2, colour = cell_type2)) + 
       geom_quasirandom(groupOnX = F) + theme_classic() + 
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("Células ordenadas por la 1ªCP") + 
       xlab("Primera componente principal") + ylab("Etapa de desarrollo") + 
       scale_colour_calc()
```

Aplicando dicho algoritmo básico, y tal y como muestra el gráfico anterior, vemos que a la primera dimensión le cuesta un poco diferenciar algunos tipos celulares, pero en general ordena bien las células según su estapa de desarrollo.

En las siguientes secciones veremos qué rendimiento desempeñan los algoritmos previamente citados ( _i.e._ TSCAN y sucedáneos).



***

<br>

# TSCAN

`TSCAN` combina el clustering con el análisis de pseudotiempo. Primero agrupa las células usando `mclust`, el cual se basa en una mezcla de distribuciones normales. Seguidamente construye un árbol del menor tamaño posible que conecte los clusters. La rama principal del árbol será la que conecte el mayor nº de clusters, y es la rama que se usa para determinar el pseudotiempo.

Primero intentaremos usar todos los genes para ordenar las células:

```{r}
# Preprocesamos la matriz de conteos crudos
procdeng <- TSCAN::preprocess(deng)

# Cambiamos el nombre de las columnas de tipo celular a índice numérico
colnames(procdeng) <- 1:ncol(deng)

# Hacemos el clustering con `mclust`
dengclust <- TSCAN::exprmclust(procdeng, clusternum = 10)

# Graficamos el resultado
TSCAN::plotmclust(dengclust)


# Ordenamos las células. Con `orderonly = F`, nos devuelve también el
# pseudotiempo.
dengorderTSCAN <- TSCAN::TSCANorder(dengclust, orderonly = F)
pseudotime_order_tscan <- as.character(dengorderTSCAN$sample_name)

# Creamos el bolsillo vacío "pseudotime_order_tscan" en el objeto deng_SCE
deng_SCE$pseudotime_order_tscan <- NA
deng_SCE$pseudotime_order_tscan[as.numeric(dengorderTSCAN$sample_name)] <- dengorderTSCAN$Pseudotime
```



Ahora vemos los _timepoints_ que se han asignado a cada estado celular:

```{r}
# El último cúster (nº10), o sea el último paso del pseudotiempo según TSCAN,
# corresponde a células en fase "late2cell"
cellLabels[dengclust$clusterid == 10]

# Graficamos el pseudotiempo final de TSCAN
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = pseudotime_order_tscan, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = F) + theme_classic() +
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("Células ordenadas por TSCAN") +
       xlab("pseudotiempo según TSCAN") + ylab("Etapa de desarrollo") +
       scale_colour_calc()
```


En la gráfica se aprecia que en nuestro dataset, TSCAN infiere al revés la trayectoria del desarrollo embrionario. Esto no es un problema _per se_ ya que podemos darle la vuelta al ordenamiento para entenderlo, pero no podemos asegurar que funcione mejor que el ordenamiento que hicimos mediante las coordenadas de la 1ª componente principal. El motivo de esto se debe al hecho de que TSCAN es un método de inferencia de trayectoria basado en PCA.


<details>
<summary> __Ejercicio 2.1: Compara los resultados obtenidos al variar el parámetro `clusternum` (nº de clusters) del comando `exprmclust`__ </summary>

<br>

__Solución__: en este dataset, TSCAN infiere bien en su mayoría la trayectoria del desarrollo embrionario si elegimos `clusternum` entre 3 y 8.


```{r, echo = F}
# clustering buscando 2 clusters
dengclust <- TSCAN::exprmclust(procdeng, clusternum = 2)

# Graficamos el resultado
# TSCAN::plotmclust(dengclust)


# Ordenamos las células
dengorderTSCAN <- TSCAN::TSCANorder(dengclust, orderonly = F)
pseudotime_order_tscan <- as.character(dengorderTSCAN$sample_name)

# Creamos el bolsillo vacío "pseudotime_order_tscan" en el objeto deng_SCE
deng_SCE$pseudotime_order_tscan <- NA
deng_SCE$pseudotime_order_tscan[as.numeric(dengorderTSCAN$sample_name)] <- dengorderTSCAN$Pseudotime

# Graficamos el pseudotiempo final de TSCAN
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = pseudotime_order_tscan, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = F) + theme_classic() +
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("TSCAN, 2 clusters") +
       xlab("pseudotiempo") + ylab("Etapa de desarrollo") +
       scale_colour_calc()
```

<br>

```{r, echo = F}
# clustering buscando 3 clusters
dengclust <- TSCAN::exprmclust(procdeng, clusternum = 3)

# Graficamos el resultado
# TSCAN::plotmclust(dengclust)


# Ordenamos las células
dengorderTSCAN <- TSCAN::TSCANorder(dengclust, orderonly = F)
pseudotime_order_tscan <- as.character(dengorderTSCAN$sample_name)

# Creamos el bolsillo vacío "pseudotime_order_tscan" en el objeto deng_SCE
deng_SCE$pseudotime_order_tscan <- NA
deng_SCE$pseudotime_order_tscan[as.numeric(dengorderTSCAN$sample_name)] <- dengorderTSCAN$Pseudotime

# Graficamos el pseudotiempo final de TSCAN
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = pseudotime_order_tscan, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = F) + theme_classic() +
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("TSCAN, 3 clusters") +
       xlab("pseudotiempo") + ylab("Etapa de desarrollo") +
       scale_colour_calc()
```

<br>

```{r, echo = F}
# clustering buscando 8 clusters
dengclust <- TSCAN::exprmclust(procdeng, clusternum = 8)

# Graficamos el resultado
# TSCAN::plotmclust(dengclust)


# Ordenamos las células
dengorderTSCAN <- TSCAN::TSCANorder(dengclust, orderonly = F)
pseudotime_order_tscan <- as.character(dengorderTSCAN$sample_name)

# Creamos el bolsillo vacío "pseudotime_order_tscan" en el objeto deng_SCE
deng_SCE$pseudotime_order_tscan <- NA
deng_SCE$pseudotime_order_tscan[as.numeric(dengorderTSCAN$sample_name)] <- dengorderTSCAN$Pseudotime

# Graficamos el pseudotiempo final de TSCAN
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = pseudotime_order_tscan, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = F) + theme_classic() +
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("TSCAN, 8 clusters") +
       xlab("pseudotiempo") + ylab("Etapa de desarrollo") +
       scale_colour_calc()
```

<br>

```{r, echo = F}
# clustering buscando 9 clusters
dengclust <- TSCAN::exprmclust(procdeng, clusternum = 9)

# Graficamos el resultado
# TSCAN::plotmclust(dengclust)


# Ordenamos las células
dengorderTSCAN <- TSCAN::TSCANorder(dengclust, orderonly = F)
pseudotime_order_tscan <- as.character(dengorderTSCAN$sample_name)

# Creamos el bolsillo vacío "pseudotime_order_tscan" en el objeto deng_SCE
deng_SCE$pseudotime_order_tscan <- NA
deng_SCE$pseudotime_order_tscan[as.numeric(dengorderTSCAN$sample_name)] <- dengorderTSCAN$Pseudotime

# Graficamos el pseudotiempo final de TSCAN
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = pseudotime_order_tscan, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = F) + theme_classic() +
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("TSCAN, 9 clusters") +
       xlab("pseudotiempo") + ylab("Etapa de desarrollo") +
       scale_colour_calc()
```

<br>

```{r, echo = F}
# clustering buscando 10 clusters
dengclust <- TSCAN::exprmclust(procdeng, clusternum = 10)

# Graficamos el resultado
# TSCAN::plotmclust(dengclust)


# Ordenamos las células
dengorderTSCAN <- TSCAN::TSCANorder(dengclust, orderonly = F)
pseudotime_order_tscan <- as.character(dengorderTSCAN$sample_name)

# Creamos el bolsillo vacío "pseudotime_order_tscan" en el objeto deng_SCE
deng_SCE$pseudotime_order_tscan <- NA
deng_SCE$pseudotime_order_tscan[as.numeric(dengorderTSCAN$sample_name)] <- dengorderTSCAN$Pseudotime

# Graficamos el pseudotiempo final de TSCAN
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = pseudotime_order_tscan, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = F) + theme_classic() +
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("TSCAN, 10 clusters") +
       xlab("pseudotiempo") + ylab("Etapa de desarrollo") +
       scale_colour_calc()
```

</details>


***

<br>





# Mapas de difusión: `destiny`

Los mapas de difusión fueron inventados por Ronald Coifman y Stephane Lagon, y la idea principal es asumir que los datos son muestras de un proceso de difusión. Este método infiere la estructura de los datos en un espacio de baja dimensionalidad al estimar los _eigenvalues_ y los _eigenvectors_ (valores y vectores propios) del operador de la difusión relacionado con los datos.

Angerer _et al._ han aplicado el concepto de los mapas de difusión al análisis de datos scRNA-seq para crear así un paquete de R llamado `destiny`.

Si en la sección del PCA comentábamos que el pseudotiempo era las coordenadas de la 1ª componente principal, en `destiny` el pseudotiempo pasa a ser las coordenadas de la 1ª componente de difusión.


```{r}
# Primero creamos la matriz de conteos en forma logarítmica con `logcounts`.
# Recuerda que usa el "pseucocount of 1", o sea, log2(x+1), para definir el 0.
log_deng <- logcounts(deng_SCE)

# Ponemos bien los nombres de las células en la matriz de conteos en formato
# logarítmico
colnames(log_deng) <- cellLabels

# Calculamos las componentes de difusión. Hay que transponer la matriz de
# conteos logarítmicos. Por defecto, `DiffusionMap` usa como input el PCA, creo
dm <- DiffusionMap(t(log_deng))

# Creamos un dataframe _ad interim_ con 3 columnas: DC1, DC2 y etapa_desarrollo
tmp <- data.frame(DC1 = eigenvectors(dm)[,1],
                  DC2 = eigenvectors(dm)[,2],
                  etapa_desarrollo = cellLabels) # = deng_SCE$cell_type2
```



```{r}
# Graficamos las dos primeras componentes del mapa de difusión
ggplot(tmp, aes(x = DC1, y = DC2, color = etapa_desarrollo)) + geom_point() + 
       theme_classic() + theme(plot.title = element_text(hjust = 0.5)) + 
       xlab("Componente de difusión 1") + ylab("Componente de difusión 2") + 
       scale_color_calc() + ggtitle("Mapa de difusión de destiny")
```


```{r}
# Ordenamos las células según sus coordenadas en la primera componente de
# difusión
deng_SCE$pseudotime_diffusionmap <- rank(eigenvectors(dm)[,1])

# Graficamos la trayectoria final inferida
ggplot(as.data.frame(colData(deng_SCE)), aes(x = pseudotime_diffusionmap, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = FALSE) + scale_color_calc() + theme_classic() + 
       theme(plot.title = element_text(hjust = 0.5)) + xlab("Pseudotiempo del mapa de difusión (1ª componente)") + 
       ylab("Etapa de desarrollo") + ggtitle("Células ordenadas según destiny")
```

Al igual que otros métodos, usar la 1ª componente de difusión a modo de pseudotiempo nos ayuda a ordenar las células tempranas, pero no puede distinguir las células en etapas más avanzadas del desarrollo (embrión con 8 o más células).


***

<br>




# SLICER


SLICER es un algoritmo para construir trayectorias que describen cambios en la expresión génica durante un proceso biológico secuencial (al igual que Monocle y TSCAN). SLICER está diseñado para capturar cambios de expresión génica no lineales, seleccionar automáticamente aquellos genes que participen en el proceso biológico y detectar ramas/caminos alternativos y loops en la trayectoria ([Welch _et al._, 2016](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0975-3)). El paquete de SLICER está disponible en [GitHub](https://github.com/jw156605/SLICER) y se puede instalar mediante `devtools`.


Usamos la función `select_genes` de SLICER para seleccionar automáticamente los genes que se usarán para construir la trayectoria celular. La función usa la "neighbourhood variance" para identificar los genes que varían suavemente (en lugar de aquellos que fluctúan aleatoriamente) en las células estudiadas. A continuación, determinamos el nº de vecinos cercanos o _nearest neighbours_ (parámetro `k`) que provee un _embedding_ o embebimiento lo más parecido a una trayectoria. Finalmente estimamos el _embedding_ local lineal (LLE) de las células. 


```{r}
# Para seleccionar los genes en SLICER, usamos la matriz logarítmica traspuesta.
# Ídem para seleccionar k
slicer_genes <- select_genes(t(log_deng)) # Probar counts(deng_SCE) en lugar de logcounts(deng_SCE)
k <- select_k(exp_mat = t(log_deng[slicer_genes,]), kmin = 30, kmax = 60)

# La librería `lle` permite usar el comando homónimo para calcular el LLE o
# Locally Linear Embedding
library("lle")
slicer_traj_lle <- lle(t(deng[slicer_genes,]), m = 2, k)$Y # Importante usar esta notación, si no, no funciona conn_knn_graph()


# Añadimos los resultados de la técnica de reducción de la dimensionalidad al
# objeto original deng_SCE
reducedDim(deng_SCE, type = "LLE") <- slicer_traj_lle
reducedDimNames(deng_SCE)


# Graficamos el espacio de dimensionalidad reducida
plotReducedDim(deng_SCE, dimred = "LLE", colour_by = "cell_type2") +
                xlab("Componente de LLE 1") + ylab("Componente de LLE 2") +
                ggtitle("Embebimiento lineal local (LLE) de las células - SLICER") + 
                theme(plot.title =  element_text(hjust = 0.5))
```

Ahora que hemos calculado el LLE, podemos construir un grafo basado en k-nearest neighbours (k-NN) que sea completamente conectado ( _fully connected_, como se suele decir en MLPs). Este gráfico muestra un círculo (amarillo) por cada célula, con la ID de la célula representada en azul encima del círculo. Mostramos a continuación el grafo obtenido con k = 10 vecinos.


```{r}
slicer_traj_graph <- conn_knn_graph(slicer_traj_lle, k = 10)
plot(slicer_traj_graph, main = "Fully connected kNN graph from SLICER")
```

A partir del grafo podemos identificar las células de los extremos, las cuales serán candidatas para el comienzo y el fin de la trayectoria.

```{r}
ends <- find_extreme_cells(traj_graph = slicer_traj_graph, embedding = slicer_traj_lle)
start <- 1 # No funciona con ends[1]...
```

Tras definir la célula inicial, ordenamos las células a lo largo del pseudotiempo.

```{r}
pseudotime_order_slicer <- cell_order(slicer_traj_graph, start)
branches <- assign_branches(slicer_traj_graph, start)
pseudotime_slicer <- data.frame(TimePoint = cellLabels,
                                pseudotime = NA,
                                State = branches)

pseudotime_slicer$pseudotime[pseudotime_order_slicer] <-  1:length(pseudotime_order_slicer)

deng_SCE$pseudotime_slicer <- pseudotime_slicer$pseudotime
```


We can again compare the inferred pseudotime to the known sampling timepoints. SLICER does not provide
a pseudotime value per se, just an ordering of cells.


```{r}
ggplot(as.data.frame(colData(deng_SCE)),
aes(x = pseudotime_slicer,
y = cell_type2, colour = cell_type2)) +
geom_quasirandom(groupOnX = FALSE) +
scale_color_tableau() + theme_classic() +
xlab("SLICER pseudotime (cell ordering)") + ylab("Timepoint") +
theme_classic()
```


***

<br>




# sessionInfo()

<details>

<summary> Click para mostrar </summary>

```{r, echo = F}
sessionInfo()
```

</details>