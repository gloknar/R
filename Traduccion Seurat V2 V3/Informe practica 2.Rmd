---
title: "Informe práctica 2"
author: "Adam Casas"
date: 'Compilado: `r format(Sys.Date(), "%d de %B del %Y")`'
output: 
  html_document:
    df_print: paged
    highlight: kate
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_float: yes
---

```{r configuracion_inicial, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = TRUE,
                      warning = FALSE,
                      tidy = F)
##################################################
#######        Encoded in UTF-8        ###########
##################################################
```

***

# Introducción al pseudotiempo

__El pseudotiempo es el ordenamiento basado en la similaridad de las células a lo largo de la trayectoria de un proceso de desarrollo contínuo.__



El pseudotiempo es una medida de cuánto progreso ha hecho una célula en un proceso biológico como por ejemplo la diferenciación celular. En muchos procesos biológicos, las células no progresan en perfecta sincronía. En estudios de expresión de single-cell sobre procesos tales como la diferenciación celular, las células estudiadas pueden mostrar diversos grados de desarrollo. Es decir, en una población de células capturadas exactamente a la vez, algunas células pueden estar más desarrolladas, mientras que otras pueden ni haber empezado el proceso en cuestión. Esta asincronía dificulta seriamente el estudio de la secuencia de cambios regulatorios que ocurren cuando las células transicionan de un estado a otro. Seguirle la pista a la expresión en todas las células capturadas a la vez produce un sentido muy comprimido de la cinética de un gen, y la variabilidad aparente de la expresión de ese gen será muy elevada. Al ordenar cada célula de acuerdo a su progreso a lo largo de una trayectoria aprendida, el análisis del pseudotiempo alivia los problemas derivados de la susodicha asincronía. En lugar de rastrear los cambios de la expresión génica en función del tiempo, diversas herramientas rastrean dichos cambios en función del progreso a lo largo de la trayectoria, la cual denominamos "pseudotiempo". El pseudotiempo es una unidad abstracta de progreso: en realidad es la distancia entre una célula dada y el comienzo de la trayectoria, medida a lo largo del camino más corto. La longitud total de la trayectoria se define en términos de la cantidad total de cambios transcripcionales que sufre una célula mientras se mueve del estado inicial al final.

```{r, message = F}
library("SingleCellExperiment")
library("TSCAN")
library("destiny")
library("SLICER")
library("ouija")
library("scater")
library("ggplot2")
library("ggthemes")
library("ggbeeswarm")
library("corrplot")
# library("M3Drop")
# library("monocle)
set.seed(1)
```


En muchas situaciones, uno estudia un proceso en el cual las células cambian continuamente. Esto incluye, por ejemplo, muchos procesos de diferenciación que tienen lugar durante el desarrollo del organismo: tras un estímulo, las células cambian de un tipo a otro. Idealmente, nos interesaría monitorizar los niveles de expresión de una célula dada a lo largo del tiempo. Desafortunadamente, tal monitorización no es posible en scRNA-seq dado que la célula se lisa cuando el ARN se extrae.



En su lugar, debemos muestrear en múltiples puntos del tiempo y así obtener "fotografías" de los perfiles de expresión génicos. Puesto que algunas células se diferenciarán más rápido que otras, cada fotografía puede contener células en diversas etapas del desarrollo. __Usamos métodos estadísticos para ordenar las células a lo largo de una o más trayectorias las cuales representan las trayectorias del desarrollo subyacentes, este ordenamiento se conoce como "pseudotiempo".__


En esta práctica nos centraremos en 4 herramientas para ordenar las células según su grado de desarrollo en el pseudotiempo: TSCAN, SLICER, destiny y ouija. Para ilustrar su uso, emplearemos el dataset del desarrollo embrionario en ratón de [Deng _et al._, 2014](https://science.sciencemag.org/content/343/6167/193). Dicho dataset cuenta con 268 células provenientes de la fase temprana del desarrollo embrional y extraídas en 10 puntos de tiempo. En este caso no hace falta alinear las células a la trayectoria del pseudotiempo dado que están ya etiquetadas con información sobre la trayectoria embrionaria. Por tanto, las etiquetas son la _ground truth_ o verdad experimental sobre la cual podemos comparar el rendimiento obtenido por los susodichos métodos.

Una revisión más o menos reciente de [Cannoodt _et al._](https://onlinelibrary.wiley.com/doi/full/10.1002/eji.201646347) publicada en 2016 nos aporta un resumen detallado de los distintos algoritmos empleados para la inferencia de trayectoria en scRNA-seq. Dicha revisión cubre:


* **Monocle** - Paquete de Bioconductor

* **TSCAN** - Paquete de Bioconductor

* **SLICER** - Paquete de R, disponible sólo a través de GitHub

* Waterfall - Paquete de R (se incluye un script en el suplemento del artículo original de [Shin _et al,_ 2015](https://www.cell.com/cell-stem-cell/fulltext/S1934-5909(15)00312-4) y en los [archivos asociados](https://github.com/gloknar/R-Utilities/tree/master/Traduccion%20Seurat%20V2%20V3/Cosas%20accesorias%20Informe%202) a este informe)

* Mpath - Paquete de R disponible en GitHub (comprimido con formato `tar.gz`). La función está documentada, pero el workflow no, ni tiene una _vignette_.

* Wishbone - Paquete de Python

* SCUBA - Paquete de Matlab

* Wanderlust - Paquete de Matlab

* SCOUP - Programa en C++ por línea de comandos 

<br>

Las figuras 1 y 2 del paper de Cannoodt _et al._ resumen algunas de las características de estos métodos.


![Figura 1. Descripción de los diversos métodos de inferencia de trayectoria para datos de scRNA-seq (Figura 2 de Cannoodt _et al._, 2016).](./Cosas Accesorias Informe 2/fig2.png)

<br>

![Figura 2. Caracterización de los métodos de inferencia de trayectoria para scRNA-seq (Figura 3 de Cannoodt _et al._, 2016).](./Cosas Accesorias Informe 2/fig3.png)


***

<br>

# Visualización del dataset


Al igual que el dataset de Nakamura _et al._ usado en la práctica 1, el dataset de Deng _et al._ contiene células embrionarias en los primeros estadios de Carnegie, solo que en este caso las células son de ratón, y no de macaco cangrejero. El dataset de esta práctica se encuentra en el archivo `deng-reads.rds`.


```{r}
# Leemos los datos
deng_SCE <- readRDS(file = "./Archivos accesorios/Codigo y datos de las Practicas 1-4/data/deng-reads.rds")

# Reordenamos los niveles, ya que zigoto < 2 células < 4 células, etc...
deng_SCE$cell_type2 <- factor(deng_SCE$cell_type2, 
                              levels = c("zy", "early2cell", "mid2cell", "late2cell",
                              "4cell", "8cell", "16cell", "earlyblast", "midblast", 
                              "lateblast")) 


# Generamos y formateamos una matriz de conteos
deng <- counts(deng_SCE)

cellLabels <- deng_SCE$cell_type2
colnames(deng) <- cellLabels
```


Tal como muestra el siguiente gráfico, el PCA muestra bastante bien la estructura de los datos y los separa correctamente en su mayoría, exceptuando aquellas células que corresponden al estadio de blastocisto (early/mid/lateblast), que están mezcladas entre sí. Se aprecia cómo las células están ordenadas en el espacio del PCA en sentido horario, desde la etapa de zigoto (zy) hasta la de blastocisto tardío (lateblast).

```{r}
# Corremos PCA en un objeto de tipo SingleCellExperiment
deng_SCE <- runPCA(deng_SCE)

# Graficamos el PCA
BiocGenerics::plotPCA(deng_SCE, colour_by = "cell_type2") + 
  ggtitle("PCA de células embrionarias de ratón") + 
  theme(plot.title = element_text(hjust = 0.5))
```

Aquí el PCA nos proporciona un útil punto de referencia para comprobar diversos métodos de inferencia de trayectoria. A diferencia del t-SNE y el UMAP, el PCA podría revelarnos mejor el tiempo de desarrollo, a expensas de producir un clustering peor. Un algoritmo muy sencillo de inferencia podría ser simplemente utilizar las coordenadas en el espacio del PCA de la primera componente principal. 


```{r}
deng_SCE$PC1 <- reducedDim(x = deng_SCE, type = "PCA")[,1]

# Graficamos el pseudotiempo según las coordenadas de la primera componente
# principal
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = PC1, y = cell_type2, colour = cell_type2)) + 
       geom_quasirandom(groupOnX = F) + theme_classic() + 
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("Células ordenadas por la 1ªCP") + 
       xlab("Primera componente principal") + ylab("Etapa de desarrollo") + 
       scale_colour_calc()
```

Aplicando dicho algoritmo básico, y tal y como muestra el gráfico anterior, vemos que a la primera dimensión le cuesta un poco diferenciar algunos tipos celulares, pero en general ordena bien las células según su estapa de desarrollo.

En las siguientes secciones veremos qué rendimiento desempeñan los algoritmos previamente citados ( _i.e._ TSCAN y sucedáneos).



***

<br>

# TSCAN

`TSCAN` combina el clustering con el análisis de pseudotiempo. Primero agrupa las células usando `mclust`, el cual se basa en una mezcla de distribuciones normales. Seguidamente construye un árbol del menor tamaño posible que conecte los clusters. La rama principal del árbol será la que conecte el mayor nº de clusters, y es la rama que se usa para determinar el pseudotiempo.

Primero intentaremos usar todos los genes para ordenar las células:

```{r}
# Preprocesamos la matriz de conteos
procdeng <- TSCAN::preprocess(deng)

# Cambiamos el nombre de las columnas de tipo celular a índice numérico
colnames(procdeng) <- 1:ncol(deng)

# Hacemos el clustering con `mclust`
dengclust <- TSCAN::exprmclust(procdeng, clusternum = 10)

# Graficamos el resultado
TSCAN::plotmclust(dengclust)


# Ordenamos las células. Con `orderonly = F`, nos devuelve también el
# pseudotiempo.
dengorderTSCAN <- TSCAN::TSCANorder(dengclust, orderonly = F)
pseudotime_order_tscan <- as.character(dengorderTSCAN$sample_name)

# Creamos el bolsillo vacío "pseudotime_order_tscan" en el objeto deng_SCE
deng_SCE$pseudotime_order_tscan <- NA
deng_SCE$pseudotime_order_tscan[as.numeric(dengorderTSCAN$sample_name)] <- dengorderTSCAN$Pseudotime
```



Ahora vemos los _timepoints_ que se han asignado a cada estado celular:

```{r}
# El último cúster (nº10), o sea el último paso del pseudotiempo según TSCAN,
# corresponde a células en fase "late2cell"
cellLabels[dengclust$clusterid == 10]

# Graficamos el pseudotiempo final de TSCAN
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = pseudotime_order_tscan, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = F) + theme_classic() +
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("Células ordenadas por TSCAN") +
       xlab("pseudotiempo según TSCAN") + ylab("Etapa de desarrollo") +
       scale_colour_calc()
```


En la gráfica se aprecia que en nuestro dataset, TSCAN infiere al revés la trayectoria del desarrollo embrionario. Esto no es un problema _per se_ ya que podemos darle la vuelta al ordenamiento para entenderlo, pero no podemos asegurar que funcione mejor que el ordenamiento que hicimos mediante las coordenadas de la 1ª componente principal. El motivo de esto se debe al hecho de que TSCAN es un método de inferencia de trayectoria basado en PCA.


<details>
<summary> __Ejercicio 2.1: Compara los resultados obtenidos al variar el parámetro `clusternum` (nº de clusters) del comando `exprmclust`__ </summary>

<br>

__Solución__: en este dataset, TSCAN infiere bien en su mayoría la trayectoria del desarrollo embrionario si elegimos `clusternum` entre 3 y 8.


```{r, echo = F}
# clustering buscando 2 clusters
dengclust <- TSCAN::exprmclust(procdeng, clusternum = 2)

# Graficamos el resultado
# TSCAN::plotmclust(dengclust)


# Ordenamos las células
dengorderTSCAN <- TSCAN::TSCANorder(dengclust, orderonly = F)
pseudotime_order_tscan <- as.character(dengorderTSCAN$sample_name)

# Creamos el bolsillo vacío "pseudotime_order_tscan" en el objeto deng_SCE
deng_SCE$pseudotime_order_tscan <- NA
deng_SCE$pseudotime_order_tscan[as.numeric(dengorderTSCAN$sample_name)] <- dengorderTSCAN$Pseudotime

# Graficamos el pseudotiempo final de TSCAN
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = pseudotime_order_tscan, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = F) + theme_classic() +
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("TSCAN, 2 clusters") +
       xlab("pseudotiempo") + ylab("Etapa de desarrollo") +
       scale_colour_calc()
```

<br>

```{r, echo = F}
# clustering buscando 3 clusters
dengclust <- TSCAN::exprmclust(procdeng, clusternum = 3)

# Graficamos el resultado
# TSCAN::plotmclust(dengclust)


# Ordenamos las células
dengorderTSCAN <- TSCAN::TSCANorder(dengclust, orderonly = F)
pseudotime_order_tscan <- as.character(dengorderTSCAN$sample_name)

# Creamos el bolsillo vacío "pseudotime_order_tscan" en el objeto deng_SCE
deng_SCE$pseudotime_order_tscan <- NA
deng_SCE$pseudotime_order_tscan[as.numeric(dengorderTSCAN$sample_name)] <- dengorderTSCAN$Pseudotime

# Graficamos el pseudotiempo final de TSCAN
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = pseudotime_order_tscan, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = F) + theme_classic() +
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("TSCAN, 3 clusters") +
       xlab("pseudotiempo") + ylab("Etapa de desarrollo") +
       scale_colour_calc()
```

<br>

```{r, echo = F}
# clustering buscando 8 clusters
dengclust <- TSCAN::exprmclust(procdeng, clusternum = 8)

# Graficamos el resultado
# TSCAN::plotmclust(dengclust)


# Ordenamos las células
dengorderTSCAN <- TSCAN::TSCANorder(dengclust, orderonly = F)
pseudotime_order_tscan <- as.character(dengorderTSCAN$sample_name)

# Creamos el bolsillo vacío "pseudotime_order_tscan" en el objeto deng_SCE
deng_SCE$pseudotime_order_tscan <- NA
deng_SCE$pseudotime_order_tscan[as.numeric(dengorderTSCAN$sample_name)] <- dengorderTSCAN$Pseudotime

# Graficamos el pseudotiempo final de TSCAN
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = pseudotime_order_tscan, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = F) + theme_classic() +
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("TSCAN, 8 clusters") +
       xlab("pseudotiempo") + ylab("Etapa de desarrollo") +
       scale_colour_calc()
```

<br>

```{r, echo = F}
# clustering buscando 9 clusters
dengclust <- TSCAN::exprmclust(procdeng, clusternum = 9)

# Graficamos el resultado
# TSCAN::plotmclust(dengclust)


# Ordenamos las células
dengorderTSCAN <- TSCAN::TSCANorder(dengclust, orderonly = F)
pseudotime_order_tscan <- as.character(dengorderTSCAN$sample_name)

# Creamos el bolsillo vacío "pseudotime_order_tscan" en el objeto deng_SCE
deng_SCE$pseudotime_order_tscan <- NA
deng_SCE$pseudotime_order_tscan[as.numeric(dengorderTSCAN$sample_name)] <- dengorderTSCAN$Pseudotime

# Graficamos el pseudotiempo final de TSCAN
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = pseudotime_order_tscan, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = F) + theme_classic() +
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("TSCAN, 9 clusters") +
       xlab("pseudotiempo") + ylab("Etapa de desarrollo") +
       scale_colour_calc()
```

<br>

```{r, echo = F}
# clustering buscando 10 clusters
dengclust <- TSCAN::exprmclust(procdeng, clusternum = 10)

# Graficamos el resultado
# TSCAN::plotmclust(dengclust)


# Ordenamos las células
dengorderTSCAN <- TSCAN::TSCANorder(dengclust, orderonly = F)
pseudotime_order_tscan <- as.character(dengorderTSCAN$sample_name)

# Creamos el bolsillo vacío "pseudotime_order_tscan" en el objeto deng_SCE
deng_SCE$pseudotime_order_tscan <- NA
deng_SCE$pseudotime_order_tscan[as.numeric(dengorderTSCAN$sample_name)] <- dengorderTSCAN$Pseudotime

# Graficamos el pseudotiempo final de TSCAN
ggplot(as.data.frame(colData(deng_SCE)), 
       aes(x = pseudotime_order_tscan, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = F) + theme_classic() +
       theme(plot.title = element_text(hjust = 0.5)) +
       ggtitle("TSCAN, 10 clusters") +
       xlab("pseudotiempo") + ylab("Etapa de desarrollo") +
       scale_colour_calc()
```

</details>


***

<br>


# Mapas de difusión: `destiny`

Los mapas de difusión fueron inventados por Ronald Coifman y Stephane Lagon, y la idea principal es asumir que los datos son muestras de un proceso de difusión. Este método infiere la estructura de los datos en un espacio de baja dimensionalidad al estimar los eigenvalues y los eigenvectors del operador de la difusión relacionado con los datos.

Angerer _et al._ han aplicado el concepto de los mapas de difusión a los datos de scRNA-seq para crear un paquete de R llamado `destiny`.

En este paso, tomaremos el orden de las células en la primera componente del mapa de difusión como el "pseudotiempo del mapa de difusión".

```{r}
# Primero usamos `logcounts` del paquete `SingleCellExperiment`.
#
# Get or set a matrix of log-transformed counts or count-like values. In most
# cases, this will be defined as log-transformed normcounts, e.g., using log
# base 2 and a pseudo-count of 1. Pseudocuenta de 1 = log2(x+1)
deng <- logcounts(deng_SCE)

colnames(deng) <- cellLabels

# Calculamos las componentes de difusión
dm <- DiffusionMap(t(deng))
# ?DiffusionMap

# Creamos un dataframe con 3 columnas: DC1, DC2 y etapa_desarrollo
tmp <- data.frame(DC1 = eigenvectors(dm)[,1],
                  DC2 = eigenvectors(dm)[,2],
                  etapa_desarrollo = deng_SCE$cell_type2)
```

```{r}
# Graficamos las dos primeras componentes del mapa de difusión
ggplot(tmp, aes(x = DC1, y = DC2, color = etapa_desarrollo)) + geom_point() + 
       theme_classic() + theme(plot.title = element_text(hjust = 0.5)) + 
       xlab("Componente de difusión 1") + ylab("Componente de difusión 2") + 
       scale_color_calc() + ggtitle("destiny")
```


```{r}
# Ordenamos las células según sus coordenadas en la primera componente del mapa
# de difusión
deng_SCE$pseudotime_diffusionmap <- rank(eigenvectors(dm)[,1])

# Graficamos
ggplot(as.data.frame(colData(deng_SCE)), aes(x = pseudotime_diffusionmap, y = cell_type2, colour = cell_type2)) +
       geom_quasirandom(groupOnX = FALSE) + scale_color_calc() + theme_classic() + 
       theme(plot.title = element_text(hjust = 0.5)) + xlab("Pseudotiempo del mapa de difusión (1ª componente)") + 
       ylab("Etapa de desarrollo") + ggtitle("Células ordenadas según el pseudotiempo del mapa de difusión")
```


Like the other methods, using the first diffusion map component from destiny as pseudotime does a good
job at ordering the early time-points (if we take high values as “earlier” in developement), but it is unable
to distinguish the later ones.


***

<br>


# sessionInfo()

<details>

<summary> Click para mostrar </summary>

```{r, echo = F}
sessionInfo()
```

</details>