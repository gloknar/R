---
title: "Tutorial Seurat V3 2.700 PBMCs"
author: "Adam Casas"
date: 'Compilado: `r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    df_print: paged
    highlight: kate
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  tidy = TRUE
)
```

Adaptado de la guía gratuita publicada por [10X Genomics](https://www.dropbox.com/s/38h5zccv0b7l9pr/pbmc3k_tutorial.Rmd?dl=1).

# Introducción a Seurat V3

`Seurat` es un paquete de R diseñado para trabajar con datos de single-cell RNA-seq (o secuenciación de ARN de célula única, en español). Con este paquete podrás realizar control de calidad, exploración y análisis de los ya mencionados datos. `Seurat` permite al usuario identificar e interpretar fuentes de heterogeneidad en mediciones de transcriptómica de célula única, e integrar diversos tipos de datos de célula única.

Si usas este paquete en tus investigaciones, sus desarrolladores recomiendan citar las siguientes fuentes:

* [Butler _et al._, Nature Biotechnology 2018](https://www.nature.com/articles/nbt.4096)

* [Stuart\*, Butler*, _et al._, Cell 2019](https://www.cell.com/cell/fulltext/S0092-8674(19)30559-8)


`Seurat` hace especial énfasis en las visualizaciones sencillas, interpretables y agradables a la vista, y han sido diseñadas para su fácil manejo tanto para investigadores computacionales como experimentales ( _i.e._ investigadores _in-silico_ e _in-vitro_).

Este paquete ha sido desarrollado y es actualmente mantenido por Andrew Butler, Paul Hoffman, Tim Stuart, Christoph Hafemeister, y Shiwei Zheng, todos ellos investigadores del [laboratorio Satija](https://satijalab.org/), en colaboración con otros tantos contribuyentes tales como Jeff Farrell y Karthik Shekhar, por mencionar algunos.

***

<br>


# Workflow en Seurat para el análisis de single-cell RNA-seq

Para introducirnos en el workflow de `Seurat`, analizaremos el dataset de 2700 células mononucleares de sangre periférica (PBMCs en inglés), publicado por [10x Genomics](https://www.10xgenomics.com/). En este dataset se secuenciaron mediante técnicas de single-cell RNA-seq 2700 células en la plataforma NextSeq 500 de Illumina.

> Nota: Las PBMCs corresponden a linfocitos y monocitos.

En este tutorial se trabajará el control de calidad o QC, filtrado de datos, cálculo de genes con elevada varianza, reducción de dimensionalidad, clustering basado en grafos e identificación de marcadores de clusters.

***

<br>

## Creamos el objeto Seurat "pbmc"

Para comenzar el tutorial, primero necesitamos descargar las lecturas crudas de la plataforma NextSeq 500, las cuales están disponibles en mi repositorio de [GitHub](https://github.com/gloknar/R-Utilities/tree/master/Tutorial%20Seurat%202700%20PBMCs) en forma de archivo comprimido, y ubicarlas en la misma carpeta que este script.

Empezamos cargando las librerías a emplear y leyendo los datos crudos. El comando `Read10X` lee el output del pipeline ["Cell Ranger"](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger) de 10X Genomics y devuelve una matriz de conteo de Identificadores Moleculares Únicos (o UMI en inglés). Los valores en esta matriz representan el nº de moléculas para cada característica ( _i.e._ gen; fila) que son detectados en cada célula (columna).

A continuación usamos la matriz de conteos para crear un objeto de tipo `Seurat`. Este objeto sirve a modo de contenedor tanto para los datos (la matriz de conteos, por ejemplo) como para los análisis (resultados del PCA o un clustering) de un dataset de célula única. Para una descripción técnica de la estructura de los objetos de tipo `Seurat`, consulta la [Wiki](https://github.com/satijalab/seurat/wiki) que han habilitado sus desarrolladores en GitHub.


```{r}
# Librerías
library(dplyr)
library(Seurat)
library(patchwork)
library(curl)


# La carpeta de trabajo será la ubicación de este script
setwd("./")


# Descargamos y descomprimimos las lecturas crudas:
url_lecturas <- "https://github.com/gloknar/R-Utilities/raw/master/Tutorial%20Seurat%202700%20PBMCs/pbmc3k_filtered_gene_bc_matrices.tar.gz"
curl_download(url_lecturas, destfile = "pbmc3k_filtered_gene_bc_matrices.tar.gz")
untar("pbmc3k_filtered_gene_bc_matrices.tar.gz", exdir = "./")


# Cargamos la matriz de conteos de nuestras 2.700 PBMCs
datos.pbmc <- Read10X(data.dir = "./filtered_gene_bc_matrices/hg19/")


# Inicializamos el objeto Seurat con los datos crudos (no normalizados)
pbmc <- CreateSeuratObject(
  counts = datos.pbmc, 
  project = "2700-PBMCs", 
  min.cells = 3, 
  min.features = 200)

pbmc
```


<details>
  <summary>**¿Qué apariencia tienen los datos en la matriz de conteo?**</summary>
<br>

La previamente mencionada matriz de conteos de UMIs se guardó en el objeto `datos.pbmc`. Recordemos que cada fila de esta matriz corresponde a un gen, y cada columna corresponde al nº de transcritos detectados en cada célula, de manera que la primera columna corresponde a los transcritos detectados en la célula nº1, la segunda columna corresponde a los transcritos de la célula nº2, y así.

```{r}
# Veamos la expresión de 4 genes concretos en las primeras 30 células
datos.pbmc[c("SERPINC1", "CD3D", "TCL1A", "MS4A1"), 1:30]
```
Los puntos (".") de la matriz representan ceros (no se detectaron transcritos de ARNm de ese gen, en esa célula). Así, vemos que en la primera célula sólo se detectaron 4 moléculas de ARNm del gen CD3D, mientras que en la 9ª célula se encontraron transcritos de CD3D, TCL1A y MS4A1.

Dado que la mayoría de valores en una matriz de scRNA-seq suelen ser 0, Seurat usa una "sparse-matrix" o matriz dispersa siempre que sea posible (como es en este caso). Ello disminuye la cantidad de memoria usada y acelera el procesado de los datos.

```{r}
matriz_normal <- object.size(as.matrix(datos.pbmc))
matriz_normal

matriz_dispersa <- object.size(datos.pbmc)

cat("Al guardar los datos en formato matriz dispersa en vez de matriz normal, conseguimos reducir el tamaño de los datos en un factor de", matriz_normal[1]/matriz_dispersa[1])
```
</details>

***

<br>


## Control de calidad y selección de células para posteriores análisis


Los pasos mostrados a continuación abarcan el workflow estándar para el preprocesado de datos de scRNA-seq. Estos incluyen la selección y filtrado de células en función del control de calidad, normalizado y escalado de datos y la detección de transcritos con gran varianza.


Seurat te permite explorar fácilmente las métricas del control de calidad y filtrar células según el criterio establecido por el usuario. Algunas de las métricas de calidad más usadas por la comunidad son:

* Nº de genes expresados en cada célula

  * Células mal secuenciadas o gotículas vacías suelen expresar muy pocos genes
  
  * Doublets y multiplets (gotículas con más de una célula) suele expresar un nº anormalmente alto de genes

* Nº total de transcritos detectados en una célula (lo cual está muy correlacionado con nº de genes expresados)

* Porcentaje de transcritos que mapean en el genoma mitocondrial
  
  * Las células mal secuenciadas y las moribundas suelen mostrar muchos transcritos provenientes de genes mitocondriales
  
  * Para calcular las métricas de calidad mitocondriales, se emplea el comando `PercentageFeatureSet`, el cual calcula el porcentaje de transcritos provenientes de un set de genes (en este caso, genes mitocondriales)
  
  * Los genes cuyo nombre comienzan por "MT-" son genes mitocondriales



> Nota: Durante el aislamiento de células individuales (antes de ser secuenciadas), estas son embebidas en gotículas de aceite de manera que, idealmente, en cada gotícula se halle una única célula (ver imagen inferior, sacada de Bach _et al._, [2017](https://www.nature.com/articles/s41467-017-02001-5)).

<center>

![](./imagenes/aislamiento-celulas.png)

</center>



```{r}
# Los operadores [[ ]] permiten añadir la columna "percent.mt" a los metadatos del objeto Seurat, guardados en el bolsillo @meta.data (pbmc@meta.data).
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
```



<details>
  <summary>**¿Dónde se almacenan las métricas del control de calidad en Seurat?**</summary>
  
* El nº de genes expresados (`nFeature_RNA`) y moléculas de ARNm detectadas (`nCount_RNA`) se calculan automáticamente al llamar a la función `CreateSeuratObject`

  * En concreto, se almacenan en los metadatos del objeto Seurat

  
```{r}
# Mostramos las métricas del control de calidad de las 5 primeras células
head(pbmc@meta.data, 5)
```


</details>


<br>


En el ejemplo a continuación, visualizamos las métricas de calidad y las empleamos para filtrar las células

* Vamos a descartar las células que expresen más de 2500 genes y las que expresen menos de 200

* También filtraremos las células cuyos transcritos mitocondriales supongan >=5% del total de transcritos presentes en ellas



```{r}
# Visualizamos las métricas de calidad en un gráfico de violín
VlnPlot(pbmc, features = c("nFeature_RNA", "percent.mt"), ncol = 3)

# Filtramos las células según los criterios de calidad previamente mencionados
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)

# Visualizamos las células retenidas por el filtrado
VlnPlot(pbmc, features = c("nFeature_RNA", "percent.mt"), ncol = 3)
```

***

## Normalización de datos

Tras filtrar las células indeseadas de nuestro conjunto de datos, el siguiente paso es normalizar los niveles de expresión génica mediante el comando `NormalizeData`. `NormalizeData` usa por defecto un factor de escala de 10<sup>4</sup> y el método `LogNormalize`, el cual normaliza los niveles de expresión génica de cada célula de la siguiente manera: Para un gen concreto, divide su nº de transcritos entre el nº total de transcritos presentes en esa célula, luego se multiplica por el factor de escala especificado, y al resultado de esa multiplicación (llamémoslo "x") se le aplica la transformación $ln(1+x)$ (se usa ln(1+x) en lugar de ln(x) para evitar perder precisión cuando x es un número flotante cercano a 0).

```{r}
pbmc <- NormalizeData(pbmc)
```


Los niveles de expresión génica normalizados de nuestras células se almacenan en `pbmc[["RNA"]]@data` (también puedes escribirlo como `pbmc@assays$RNA@data`).


```{r}
# Nº de transcritos tras el normalizado, se muestran las 3 primeras células
pbmc[["RNA"]]@data[968:974,1:3]
```


***

<br>

## Identificación de genes con gran varianza (selección de genes)

A continuación calculamos un subconjunto de genes cuya expresión génica presente una gran varianza (o sea, que se expresen mucho en algunas células, y que apenas se expresen en otras). 10X Genomics y otros tantos [investigadores](https://www.nature.com/articles/nmeth.2645) han descubierto que centrarse en el análisis de estos genes ayuda a resaltar señales biológicas en datasets de célula única.

El comando `FindVariableFeatures` modela la relación media-varianza de los genes para detectar aquellos con mayor varianza, y por defecto devuelve 2.000 genes. La implementación de dicho comando en Seurat se debe al trabajo de [10X Genomics](https://www.nature.com/articles/nmeth.2645).


```{r}
pbmc <- FindVariableFeatures(pbmc)

# Identificamos los top 10 genes más variables con el comando VariableFeatures
top10 <- head(VariableFeatures(pbmc), 10)

# Graficamos los genes más variables con sus nombres
grafico_genes_variable <- VariableFeaturePlot(pbmc)
LabelPoints(grafico_genes_variable, points = top10, repel = TRUE)
```

> Nota: Fíjate en que el gráfico generado se asemeja, en diseño y concepto, a los [gráficos MA](https://www.researchgate.net/figure/MA-plot-MA-plot-for-differential-expression-analysis-in-four-RNA-seq-samples-with-two_fig2_230780119) empleados en transcriptómica.

***

<br>


## Escalado de datos

Después de la normalización de los datos, los escalamos. Este es un paso estándar y previo a la aplicación de técnicas de reducción de dimensionalidad (también llamadas en su conjunto como "extracción de características" en el ámbito de Machine Learning). 

El comando `ScaleData`:

* Cambia la expresión de cada gen de manera que su expresión media en todas las células sea 0

* Escala la expresión de cada gen, de manera que su varianza a lo largo de todas las células sea 1

  * Este paso previene que genes con expresión constitutiva tengan más peso en los próximos análisis que genes con escasa expresión (por ejemplo, aquellos que codifican para factores de transcripción)
  
* Los datos escalados se guardan en `pbmc[["RNA"]]@scale.data`

* Escala por defecto sólo los genes variables identificados en el paso anterior

  * Si quieres escalar todos los genes, debes pasarle a la función el nombre de todos los genes a través del parámetro `features`

```{r}
#nombres_genes <- rownames(pbmc)
#pbmc <- ScaleData(pbmc, features = nombres_genes)
pbmc <- ScaleData(pbmc)
```

***

<br>

## Reducción de la dimensionalidad del dataset (PCA)

Seguidamente realizamos un PCA a los datos escalados. Por defecto, solo se le aplica el PCA a los genes variables previamente seleccionados, pero puedes añadir más genes al análisis si quieres mediante el argumento `features` de la función `RunPCA`. El resultado se almacena en `pbmc[["pca"]]`.

```{r}
pbmc <- RunPCA(pbmc)
```

Podemos visualizar el PCA con el comando `DimPlot` y seleccionando en el parámetro `reduction` la técnica empleada, que en este caso es el pca.

```{r}
DimPlot(pbmc, reduction = "pca", dims = c(1,2))
```

El comando `DimHeatmap` en particular ofrece una fácil exploración de las fuentes primarias de heterogeneidad en el dataset en cuestión, y nos puede ayudar a determinar qué componentes principales deberíamos analizar. Tanto los genes como las células son ordenados en función de sus loadings del PCA. Podemos seleccionar el nº de células a analizar en cada heatmap, de manera que el heatmap no tarde demasiado en dibujarse en pantalla cuando trabajemos con datasets grandes.

```{r}
DimHeatmap(pbmc, dims = 1, cells = 500)

DimHeatmap(pbmc, dims = 1:6, cells = 500)
```

Nótese que se podría aplicar un análisis de enriquecimiento génico a los resultados de estos heatmaps, de manera que podamos identificar las facetas biológicas que describen cada componente principal.


***

<br>


## Determinar la dimensionalidad del dataset

Una vez realizado el PCA, y sabiendo que cada componente principal explica una faceta distinta de las poblaciones celulares estudiadas, nos puede surgir la siguiente pregunta: ¿con cuántas componentes principales debería quedarme? ¿10, 20, 50?

Existen varias maneras o criterios a seguir a la hora de elegir el nº adecuado de dimensiones que estudiar. No obstante, en este tutorial nos centraremos en el método implementado por 10X Genomics en  [Macosko _et al._, 2015](https://www.cell.com/fulltext/S0092-8674(15)00549-8). En dicha publicación aplican exitosamente un test de remuestreo inspirado en la técnica JackStraw ([Chung y Storey, 2015](https://academic.oup.com/bioinformatics/article/31/4/545/2748186)).

Dicho test consiste en permutar aleatoriamente un subconjunto de los datos (el 1% por defecto), volver a ejecutar el PCA (con lo que se genera una distribución nula de los loadings de los genes) y repetir el proceso. Se identifican como dimensiones significativas aquellas enriquecidas con muchos genes cuyos p-valores sean bajos.

```{r, cache=T}
# Nota: El JackStraw puede tardar en completarse
pbmc <- JackStraw(pbmc)
pbmc <- ScoreJackStraw(pbmc, dims = 1:15)
```


La función `JackStrawPlot` nos permite comparar de manera visual la distribución de los p-valores de cada componente principal con una distribución uniforme (línea discontínua). Las componentes principales significativas muestran un gran enriquecimiento de genes con p-valores bajos y se situarán muy por encima de la línea discontínua. En este caso se observa que el p-valor aumenta bastante entre la duodécima y la decimotercera componente principal.


```{r}
# Visualizamos las componentes principales significativas
JackStrawPlot(pbmc, dims = 1:15)
```


Si bien el método JackStraw es efectivo, también es cierto que es computacionalmente costoso, sobre todo en datasets muy grandes, en cuyo caso uno puede optar por usar el Scree test/método del codo. En este caso, nos quedaríamos con las 7 primeras dimensiones:

```{r}
ElbowPlot(pbmc)
```


Identificar la verdadera dimensionalidad del dataset puede resultar ser una tarea laboriosa e incierta, y existen varios métodos para responder a esta cuestión. En nuestro caso, los métodos probados ofrecieron un nº parecido de dimensiones a estudiar. No obstante, los resultados de los próximos análisis no suelen variar mucho si cogemos más dimensiones de las necesarias (¡pero se ven muy perjudicados si usamos un nº insuficiente de dimensiones!), por lo que 10X Genomics recomienda tender hacia la parte superior del espectro. En nuestro caso, podríamos elegir conservar entre 7 y 12 componentes principales, por lo que el criterio de 10X Genomics nos puede encaminar hacia la elección de 10 componentes principales, por ejemplo.


***

<br>

## Agrupar las células (Clustering)

Seurat v3 aplica un clustering basado en grafos, desarrollado a partir de las estrategias empleadas en el artículo previamente mencionado de [Macosko _et al._, 2015](https://www.cell.com/fulltext/S0092-8674(15)00549-8) e inspirado en otros artículos donde se emplea clustering basado en grafos a datos de scRNA-seq [SNN-Cliq, Xu y Su, Bioinformatics, 2015](https://academic.oup.com/bioinformatics/article/31/12/1974/214505) y CyTOF [PhenoGraph, Levine _et al._, Cell, 2015](https://pubmed.ncbi.nlm.nih.gov/26095251/). En resumidas cuentas, estos métodos insertan las células en una estructura de forma de grafo (por ejemplo, un grafo basado en K-nearest neighbours (KNN), con los enlaces dibujados entre células con perfiles de expresión génica similares, y luego intentar particionar este grafo en "comunidades" o clústers densamente interconectados ( _quasi-cliques_). 

Como en PhenoGraph, primero construimos un grafo de KNN basado en la distancia euclídea en el espacio del PCA, y refinamos los pesos de los enlaces entre dos células, basándonos en el solape compartido entre dos vecindades locales (Similaridad de Jaccard). Este paso se realiza con el comando `FindNeighbors`, y toma como input la dimensionalidad del dataset previamente definida (por defecto usas las primeras 10 componentes principales).

Para agrupar  en clusters las células, a continuación aplicamos técnicas de  optimizacion de la modularidad tales como  el algoritmo de Louvain (por defecto), o SLM ([SLM, Blondel *et al.*, Journal of Statistical Mechanics](http://dx.doi.org/10.1088/1742-5468/2008/10/P10008)), para agrupar células iterativamente, con el objetivo, con el objetivo de optimizar la función estándar de modularidad. El comando `FindClusters` implementa este procedimiento, y contiene el parámetro `resolution`(resolución) que establece la "granularidad" de los posteriores clusterings, y cuando tenemos un valo alto de `resolution`, más clusters generamos. 10X Genomics recomienda usar un `resolution` de entre 0,4 y 1,2 para datasets de single-cell de 3000 células. Para datasets con más de 3000, se recomienda usar valores más altos.

Se puede comprobar a qué clúster pertenece cada célula con el comando `Idents(pbmc)`. En nuestro caso usamos `resolution = 0,5` dado que nuestro dataset es de 2700 células polimorfonucleadas de sangre periférica.

```{r, fig.height=5, fig.width=7}
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)

# Observamos las IDs de los clusters a los que pertenecen las 5 primeras células.
head(Idents(pbmc), 5)
```


***

<br>

```{r, eval=F}
#####################CLUSTER THE CELLS##################################################

pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)

# Look at cluster IDs of the first 5 cells
head(Idents(pbmc), 5)










#####################RUN NON-LINEAR DIMENSIONAL REDUCTION (t-SNE/UMAP)########################

# If you haven't installed UMAP, you can do so via reticulate::py_install(packages =
# 'umap-learn')
pbmc <- RunUMAP(pbmc, dims = 1:10)

# note that you can set `label = TRUE` or use the LabelClusters function to help label
# individual clusters
DimPlot(pbmc, reduction = "umap")

saveRDS(pbmc, file = "./2700pbmc_tutorial.rds")










#####################FINDING DIFFERENTIALLY EXPRESSED FEATURES (CLUSTER BIOMARKERS)########################

# find all markers of cluster 1
cluster1.markers <- FindMarkers(pbmc, ident.1 = 1, min.pct = 0.25)
head(cluster1.markers, n = 5)


# find all markers distinguishing cluster 5 from clusters 0 and 3
cluster5.markers <- FindMarkers(pbmc, ident.1 = 5, ident.2 = c(0, 3), min.pct = 0.25)
head(cluster5.markers, n = 5)


# find markers for every cluster compared to all remaining cells, report only the positive ones
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)



cluster1.markers <- FindMarkers(pbmc, ident.1 = 0, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)

VlnPlot(pbmc, features = c("MS4A1", "CD79A"))

# you can plot raw counts as well
VlnPlot(pbmc, features = c("NKG7", "PF4"), slot = "counts", log = TRUE)


FeaturePlot(pbmc, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP", 
                               "CD8A"))


top10 <- pbmc.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
DoHeatmap(pbmc, features = top10$gene) + NoLegend()












#####################ASSIGNING CELL TYPE IDENTITY TO CLUSTERS########################

new.cluster.ids <- c("Naive CD4 T", "Memory CD4 T", "CD14+ Mono", "B", "CD8 T", "FCGR3A+ Mono", 
                     "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()


saveRDS(pbmc, file = "./2700pbmc_final.rds")
```


# Bibliografía

Bach, K., S. Pensa, M. Grzelak, J. Hadfield, D. J. Adams, J. C. Marioni, and W. T. Khaled. 2017. “Differentiation dynamics of mammary epithelial cells revealed by single-cell RNA sequencing.” Nat Commun 8 (1): 2128.
