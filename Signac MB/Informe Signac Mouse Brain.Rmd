---
title: "Análisis de datos scATAC-seq en Signac: cerebro murino"
author: "Adam Casas"
date: 'Compilado: `r format(Sys.Date(), "%d de %B del %Y")`'
output: 
  html_document:
    df_print: paged
    highlight: kate
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_float: yes
---

```{r configuracion_inicial, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = F,
                      warning = F)
set.seed(1)
##################################################
#######        Encoded in UTF-8        ###########
##################################################
```

```{r Paralelizado protocolo, echo = F}
# Establecemos el límite de tamaño que puede usar `future` en 2 GBs dado que de
# lo contrario superamos el límite por defecto de 500 MBs al trabajar con objetos
# tan grandes
library("future")
plan(strategy = "multisession", workers = 4)
options(future.globals.maxSize = 2 * 1024^3)
```


***

# Instalación

Instalamos `Signac` en R versión 4.1:

```{r, eval = F}
BiocManager::install("Rsamtools")
install.packages("Signac")
```



***

<br>

# Introducción

`Signac` (Stuart _et al._, 2020) es una extensión del famoso paquete `Seurat` para explorar, analizar e interpretar datasets de scATAC-seq. ATAC-seq (y su variante de célula única) es, por decirlo de alguna manera, la sucesora espiritural de técnicas de secuenciación como ChIP-seq y RRBS-Seq (un tipo de secuenciación por bisulfito). Si en dichas técnicas se estudia el estado epigenético de las células/tejidos de interés, cierto es que se debe tener un conocimiento previo de cómo funcionan los mecanismos epigenéticos del organismo en cuestión para poder sacarles el mayor rendimiento. __ATAC-seq__, por otro lado, evade dicha imposición al estudiar directamente la __accesibilidad de la cromatina__ a la transposasa hiperactiva Tn5 de manera "agnóstica" (sin necesidad de conocer _a priori_ los mecanismos epigenéticos subyacentes).


En este informe vamos a presentar `Signac` mediante el análisis de un dataset compuesto por 5000 células provenientes de un cerebro de ratón adulto. Para ello debemos descargar primero los siguientes archivos, disponibles en la página web de [10X Genomics](https://support.10xgenomics.com/single-cell-atac/software/pipelines/latest/output/matrices): 

```{r, eval = F}
# El archivo con los datos crudos del ATAC-seq
download.file(
  "http://cf.10xgenomics.com/samples/cell-atac/1.1.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.h5", 
  destfile = "./archivos_accesorios/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.h5")

# Sus metadatos
download.file(
  "http://cf.10xgenomics.com/samples/cell-atac/1.1.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_singlecell.csv", 
  destfile = "./archivos_accesorios/atac_v1_adult_brain_fresh_5k_singlecell.csv")

# El archivo de los fragmentos
download.file(
  "http://cf.10xgenomics.com/samples/cell-atac/1.1.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz", 
  destfile = "./archivos_accesorios/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz")

# El archivo con el índice de los fragmentos
download.file(
  "http://cf.10xgenomics.com/samples/cell-atac/1.1.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz.tbi", 
  destfile = "./archivos_accesorios/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz.tbi")
```


<br>

Ahora cargamos las librerías que vamos a usar:

```{r, message=F, warning=F}
# Análisis
library("Signac")
library("Seurat")
# Genomas
library("GenomeInfoDb")
library("EnsDb.Mmusculus.v79")
# Gráficos
library("ggplot2")
library("patchwork")
set.seed(1234)
```




***

<br>

# Preprocesado

`Signac` requiere dos archivos generados por el software _CellRanger_ para poder preprocesar datos de ATAC-Seq:

* __Peak/Cell matrix o matriz de picos/célula__. La matriz de picos/célula es similar a la matriz de expresión génica de dimensiones _genes_ x _células_ usada en scRNA-Seq. En ATAC-Seq la matriz es de _regiones cromosómicas_ x _células_. Cada valor de la matriz es el nº de sitios de integración de Tn5 en cada célula que mapean en dichas regiones o _peaks_. A mayor nº de sitios de integración mapeados en un locus, más abierta está la cromatina en dicha región.

* __Fragment file o archivo de fragmentos__. Representa la lista completa de fragmentos únicos (= lecturas) detectados en todas las células y es por tanto un archivo MUY pesado. Al ser tan pesado, se guarda en el disco duro en lugar de la RAM y a consecuencia manipularlo es un proceso lento. Su ventaja es que contiene todos los sitios de integración de Tn5 en cada célula.


Ya que `Signac` es una extensión de `Seurat`, vamos a trabajar con un objeto `seurat` generado a partir de la __matriz de picos/célula__, sus __metadatos__ creados en `cellranger-atac` y el __archivo de fragmentos__:

```{r}
# Cargamos y visualizamos las 6 primeras filas de la matriz de ATAC_Seq en el
# objeto `matriz_picos_ATAC`:
matriz_picos_ATAC <- Read10X_h5(
  "E:/Git/R/Signac MB/archivos_accesorios/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.h5")

matriz_picos_ATAC[c(1:5), c(1:5)]


# Cargamos y exploramos el archivo de metadatos
metadatos <- read.csv(
  file = "E:/Git/R/Signac MB/archivos_accesorios/atac_v1_adult_brain_fresh_5k_singlecell.csv",
  header = TRUE,
  row.names = 1)

metadatos[c(1:5), c(1:5)]
dim(metadatos)
summary(metadatos)


# Creamos un objeto de tipo `ChromatinAssay`, necesario para generar el objeto
# de tipo `seurat`
ensayo_ATAC_Seq <- CreateChromatinAssay(
  counts = matriz_picos_ATAC,
  sep = c(":", "-"),
  genome = "mm10",
  fragments = "E:/Git/R/Signac MB/archivos_accesorios/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz",
  min.cells = 1)


# Finalmente creamos el objeto `seurat`
MB_Signac <- CreateSeuratObject(
  counts = ensayo_ATAC_Seq,
  assay = "peaks",
  project = "ATAC",
  meta.data = metadatos)


MB_Signac
MB_Signac[["peaks"]]
```


<br>

Los datos de la secuenciación ATAC se guardan en un objeto de tipo `ChromatinAssay`, el cual se caracteriza por presentar bolsillos para almacenar información adicional sobre motifs, anotaciones de los genes e información del genoma. A partir de dicho objeto creamos el principal objeto `seurat` donde realizaremos los análisis.  

Podemos usar la función `granges()` en un objeto de tipo `seurat` que tenga como experimento activo uno de tipo `ChromatinAssay` para observar las regiones cromosómicas (provenientes del archivo de fragmentos) asociadas a cada feature (gen?) del objeto. Para más información sobre la clase `ChromatinAssay`, consulte la [viñeta de interacción con objetos](https://satijalab.org/signac/articles/data_structures.html).


```{r}
# Exploración del ensayo/experimento de ATAC-Seq
ensayo_ATAC_Seq[1:5, 1:5]
dim(ensayo_ATAC_Seq) # Las columnas son las células secuenciadas y las filas son regiones cromosómicas... 5337 células y 157.203 regiones cromosómicas estudiadas
granges(MB_Signac)
```



<br>

También podemos añadir al objeto `MB_Signac` las anotaciones del genoma murino para que ciertos comandos puedan hacer uso de dicha información. 

```{r}
# Descargamos las anotaciones del genoma murino mm10 desde la base de datos
# Ensembl
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Mmusculus.v79)

# Las anotaciones están en formato NCBI. Vamos a cambiarlas al formato UCSC y
# especificaremos que estamos trabajando con el genoma mm10
seqlevelsStyle(annotations) <- "UCSC"
genome(annotations) <- "mm10"

# Añadimos las anotaciones al objeto `seurat`
Annotation(MB_Signac) <- annotations
Annotation(MB_Signac)
```

```{r, echo = F, eval = F}
seqinfo(MB_Signac)
MB_Signac@meta.data
annotations@elementMetadata
```





***

<br>

# Métricas de calidad (QC)


Ahora podemos comenzar con el control de calidad. Los desarrolladores de `Signac` recomiendan prestar atención a las siguientes métricas: 

 * __Nucleosome banding pattern__: El histograma de los tamaños de los fragmentos de ADN (de secuencias paired-end, ojo) debe exhibir un marcado patrón de bandeo de nucleosomas correspondiente a la longitud del ADN enrollado alrededor de un único nucleosoma. Esta métrica se calcula mediante la siguiente ecuación:
 
$$nucleosome\ signal = \frac{fragmentos\_mononucleosomales}{fragmentos\_sin\_nucleosomas}$$

 * __Transcriptional start site (TSS) enrichment score__. El [proyecto ENCODE](https://www.encodeproject.org/data-standards/terms/) define el _TSS enrichment score_ como el ratio de fragmentos centrados en el TSS vs fragmentos flanqueantes al TSS. Los experimentos de ATAC-Seq mal hechos suelen tener un _TSS enrichment score_ bajo. Esta métrica se calcula para cada célula con el comando `TSSEnrichment()` y se almacena en los metadatos en la columna `TSS.enrichment`.

 * __Número total de fragmentos (= lecturas) en picos__: Las células con muy pocas lecturas se han secuenciado con poca profundidad, mientras que las células con muchas lecturas podrían ser _doublets_ (dos células secuenciadas como una), agregados de núcleos u otro tipo de artefactos. Por consiguiente se deben eliminar todas las células con valores extremos de lecturas en picos.

 * __Ratio de lecturas en picos__: Representa el porcentaje de fragmentos (_i.e._ regiones cromosómicas) que caen en picos. Las células con un ratio bajo (<15~20%) suelen ser células mal secuenciadas o artefactos técnicos (ruido) y por tanto se deberían eliminar. Tenga en cuenta que el umbral de rechazo de células depende del set de picos usado.

 * __Ratio de lecturas en regiones genómicas ruidosas (_blacklists_)__. El proyecto ENCODE también ha publicado para el genoma humano (hg19 y GRCh38) y otros una [lista negra](https://github.com/Boyle-Lab/Blacklist) de regiones cromosómicas que consiste en un listado de las lecturas normalmente asociadas a ruido técnico. Las células con un porcentaje elevado lecturas que mapeen a dichos loci suelen ser ruido y deben eliminarse. Las listas negras de ENCODE actualmente disponibles en `Signac` son para genoma humano(hg19 y GRCh38), ratón (mm10), Drosophila (dm3), y _C. elegans_ (ce10).

Téngase en cuenta que las métricas `Total number of fragments in peaks`, `Fraction of fragments in peaks` y `Ratio reads in genomic blacklist regions` pueden obtenerse del output de `CellRanger` de 10X Genomics. También es posible analizar datasets no provenientes de 10X Genomics gracias a las utilidades que incorpora `Signac`.



<br>

Calculamos la intensidad de la señal de los nucleosomas con el comando `NucleosomeSignal`:

```{r}
MB_Signac <- NucleosomeSignal(object = MB_Signac)
```


Ahora podemos ver la distribución de la longitud de los fragmentos en células con una _nucleosome signal_ < 4 y > 4. Se aprecia que cada grupo de células tiene una distribución de fragmentos distinta (las células con un _nucleosome signal_ > 4 presentan un primer pico en ~200pb, a diferencia del primer pico en ~50pb que tienen aquellas con un _nucleosome signal_ < 4). 


```{r}
MB_Signac$nucleosome_group <- ifelse(MB_Signac$nucleosome_signal > 4, 'NS > 4', 'NS < 4')
FragmentHistogram(object = MB_Signac, group.by = "nucleosome_group", region = "chr1-1-10000000")
```



<br>

El enriquecimiento de eventos de integración de la Tn5 en los TSS es también una importante métrica de control de calidad. El consorcio ENCODE define la puntuación de enriquecimiento de TSSs como el nº de sitios de integración de la Tn5 alrededor del sitio de comienzo de la transcripción normalizado por el nº de sitios de integración de la TN5 en regiones flanqueantes (hasta 2000pb aguas arriba y aguas abajo). 

En `Signac` calculamos la puntuación de enriquecimiento de los TSS con el comando `TSSEnrichment()`:

```{r}
# Si usas el argumento `fast = T`, no puede ejecutar el TSSPlot, imagino que dicho
# argumento omite la matriz necesaria para dicho comando
MB_Signac <- TSSEnrichment(MB_Signac, fast = F)  
MB_Signac$high.tss <- ifelse(MB_Signac$TSS.enrichment > 2, 'High', 'Low')
TSSPlot(MB_Signac, group.by = 'high.tss') + NoLegend()
```




```{r}
# DefaultAssay(MB_Signac) # el Assay es el correcto: "peaks"
# Calculamos el nucleosome signal score por célula
MB_Signac <- NucleosomeSignal(MB_Signac)

# Calculamos el TSS enrichment score por célula
# MB_Signac <- TSSEnrichment(MB_Signac)                                                          # PURGE ME: No funciona
# https://www.encodeproject.org/atac-seq/#standards Para interpretar los valores de TSS

# Calculamos el ratio de lecturas en picos y el ratio de lecturas que caen en
# regiones ruidosas
MB_Signac$pct_reads_in_peaks <- MB_Signac$peak_region_fragments / MB_Signac$passed_filters * 100
MB_Signac$blacklist_ratio <- MB_Signac$blacklist_region_fragments / MB_Signac$peak_region_fragments
```


Podemos graficar el enriquecimiento de TSS e 

We can inspect the TSS enrichment scores by grouping the cells based on the score and plotting the accessibility signal over all TSS sites. Setting the fast=TRUE option in TSSEnrichment() will only compute the TSS enrichment score without storing the entire cell by position matrix of Tn5 insertion frequency for each cell, and can save memory. However, setting fast=TRUE will not allow downstream plotting of the TSS enrichment signal for different groups of cells using the TSSPlot() function, shown here:

```{r, eval = F}
MB_Signac$high.tss <- ifelse(MB_Signac$TSS.enrichment > 2, 'High', 'Low')
TSSPlot(MB_Signac, group.by = "high.tss") + NoLegend()
```



```{r, eval = F}
MB_Signac$nucleosome_group <- ifelse(MB_Signac$nucleosome_signal > 4, "NS > 4", "NS < 4")
FragmentHistogram(MB_Signac, group.by = "nucleosome_group")
```




```{r}
VlnPlot(
  object = MB_Signac,
  features = c("pct_reads_in_peaks", "peak_region_fragments",
               "TSS.enrichment", "blacklist_ratio", "nucleosome_signal"),
  pt.size = 0.1,
  ncol = 5
)
```




```{r}
MB_Signac <- subset(
  x = MB_Signac,
  subset = peak_region_fragments > 3000 &
    peak_region_fragments < 100000 &
    pct_reads_in_peaks > 40 &
    blacklist_ratio < 0.025 &
    nucleosome_signal < 4 &
    TSS.enrichment > 2
)

MB_Signac
```


***

<br>

## Normalization and linear dimensional reduction


```{r}
MB_Signac <- RunTFIDF(MB_Signac)
MB_Signac <- FindTopFeatures(MB_Signac, min.cutoff = 'q0')
MB_Signac <- RunSVD(MB_Signac)
```


```{r}
DepthCor(MB_Signac)
```


***

<br>

# Non-linear dimension reduction and clustering


```{r}
MB_Signac <- RunUMAP(MB_Signac, reduction = "lsi", dims = 2:30)
MB_Signac <- FindNeighbors(MB_Signac, reduction = "lsi", dims = 2:30)
MB_Signac <- FindClusters(MB_Signac, algorithm = 3, resolution = 1.2, 
                          verbose = FALSE) # Desactiva el paralelizado de `future` para evitar errores aleatorios
DimPlot(MB_Signac, label = TRUE) + NoLegend()
```




```{r}
cov_plot <- CoveragePlot(
  object = MB_Signac,
  region = "chr2-87011729-87035519",
  annotation = FALSE,
  peaks = FALSE
)

cov_plot
```


***

<br>

# Create a gene activity matrix



```{r}
# compute gene activities
gene.activities <- GeneActivity(MB_Signac)

# add the gene activity matrix to the Seurat object as a new assay
MB_Signac[['RNA']] <- CreateAssayObject(counts = gene.activities)
MB_Signac <- NormalizeData(
  object = MB_Signac,
  assay = 'RNA',
  normalization.method = 'LogNormalize',
  scale.factor = median(MB_Signac$nCount_RNA)
)
```



```{r}
DefaultAssay(MB_Signac) <- 'RNA'
FeaturePlot(
  object = MB_Signac,
  features = c('Sst','Pvalb',"Gad2","Neurod6","Rorb","Syt6"),
  pt.size = 0.1,
  max.cutoff = 'q95',
  ncol = 3
)
```


***

<br>

# Integrating with scRNA-seq data


[PH]

```{r}
# Load the pre-processed scRNA-seq data
allen_rna <- readRDS("./archivos_accesorios/allen_brain.rds")
allen_rna <- FindVariableFeatures(
  object = allen_rna,
  nfeatures = 5000
)

transfer.anchors <- FindTransferAnchors(
  reference = allen_rna,
  query = MB_Signac,
  reduction = 'cca',
  dims = 1:40
)

predicted.labels <- TransferData(
  anchorset = transfer.anchors,
  refdata = allen_rna$subclass,
  weight.reduction = MB_Signac[['lsi']],
  dims = 2:30
)

MB_Signac <- AddMetaData(object = MB_Signac, metadata = predicted.labels)
```



```{r}
plot1 <- DimPlot(allen_rna, group.by = 'subclass', label = TRUE, repel = TRUE) + NoLegend() + ggtitle('scRNA-seq')
plot2 <- DimPlot(MB_Signac, group.by = 'predicted.id', label = TRUE, repel = TRUE) + NoLegend() + ggtitle('scATAC-seq')
plot1 + plot2
```



<details>


<summary> __Why did we change default parameters?__</summary>


</details>


```{r}
# replace each label with its most likely prediction
for(i in levels(MB_Signac)) {
  cells_to_reid <- WhichCells(MB_Signac, idents = i)
  newid <- names(sort(table(MB_Signac$predicted.id[cells_to_reid]),decreasing=TRUE))[1]
  Idents(MB_Signac, cells = cells_to_reid) <- newid
}
```


***

<br>

# Find differentially accessible peaks between clusters



[PH]


```{r}
#switch back to working with peaks instead of gene activities
DefaultAssay(MB_Signac) <- 'peaks'

da_peaks <- FindMarkers(
  object = MB_Signac,
  ident.1 = c("L2/3 IT"), 
  ident.2 = c("L4", "L5 IT", "L6 IT"),
  min.pct = 0.05,
  test.use = 'LR',
  latent.vars = 'peak_region_fragments'
)

head(da_peaks)
```




```{r}
plot1 <- VlnPlot(
  object = MB_Signac,
  features = rownames(da_peaks)[1],
  pt.size = 0.1,
  idents = c("L4","L5 IT","L2/3 IT")
)
plot2 <- FeaturePlot(
  object = MB_Signac,
  features = rownames(da_peaks)[1],
  pt.size = 0.1,
  max.cutoff = 'q95'
)
plot1 | plot2
```





```{r}
open_l23 <- rownames(da_peaks[da_peaks$avg_log2FC > 0.25, ])
open_l456 <- rownames(da_peaks[da_peaks$avg_log2FC < -0.25, ])
closest_l23 <- ClosestFeature(MB_Signac, open_l23)
closest_l456 <- ClosestFeature(MB_Signac, open_l456)
head(closest_l23)
```




```{r}
head(closest_l456)
```


***

<br>

# Plotting genomic regions


placeholder



```{r}
# set plotting order
levels(MB_Signac) <- c("L2/3 IT","L4","L5 IT","L5 PT","L6 CT", "L6 IT","NP","Sst","Pvalb","Vip","Lamp5","Meis2","Oligo","Astro","Endo","VLMC","Macrophage")

CoveragePlot(
  object = MB_Signac,
  region = c("Neurod6", "Gad2"),
  extend.upstream = 1000,
  extend.downstream = 1000,
  ncol = 1
)
```


***

<br>

# Bibliografía

* Stuart _et al._ Multimodal single-cell chromatin analysis with Signac. bioRxiv (2020).

* [PH]

* [PH]

* [PH]




***

<br>

# sessionInfo()

<details>

<summary> __Click para mostrar__ </summary>

```{r, echo = F}
sessionInfo()
```

</details>