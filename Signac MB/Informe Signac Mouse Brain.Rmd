---
title: "Análisis de datos scATAC-seq en Signac: cerebro murino"
author: "Adam Casas"
date: 'Compilado: `r format(Sys.Date(), "%d de %B del %Y")`'
output: 
  html_document:
    df_print: paged
    highlight: kate
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_float: yes
---

```{r configuracion_inicial, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = F,
                      warning = F)
set.seed(1)
##################################################
#######        Encoded in UTF-8        ###########
##################################################
```

```{r Paralelizado future, echo = F}
library("future")
# Establecemos las semillas aleatorias de `future` para evitar que dé problemas
# el comando `FindClusters()`
options("future.seed" = T) 
# Establecemos el límite de tamaño que puede usar `future` en 2 GBs dado que de
# lo contrario superamos el límite por defecto de 500 MBs/hilo al trabajar con
# objetos tan grandes
options(future.globals.maxSize = 2 * 1024^3)
plan(strategy = "multisession", workers = 4)
```


***

# Instalación

Instalamos `Signac` en R versión 4.1:

```{r, eval = F}
BiocManager::install("Rsamtools")
install.packages("Signac")
```



***

<br>

# Introducción

`Signac` (Stuart _et al._, 2020) es una extensión del famoso paquete `Seurat` para explorar, analizar e interpretar datasets de scATAC-seq. ATAC-seq (y su variante de célula única) es, por decirlo de alguna manera, la sucesora espiritural de técnicas de secuenciación como ChIP-seq y RRBS-Seq (un tipo de secuenciación por bisulfito). Si en dichas técnicas se estudia el estado epigenético de las células/tejidos de interés, cierto es que se debe tener un conocimiento previo de cómo funcionan los mecanismos epigenéticos del organismo en cuestión para poder sacarles el mayor rendimiento. __ATAC-seq__, por otro lado, evade dicha imposición al estudiar directamente la __accesibilidad de la cromatina__ a la transposasa hiperactiva Tn5 de manera "agnóstica" (sin necesidad de conocer _a priori_ los mecanismos epigenéticos subyacentes).


En este informe vamos a presentar `Signac` mediante el análisis de un dataset compuesto por 5000 células provenientes de un cerebro de ratón adulto. Para ello debemos descargar primero los siguientes archivos, disponibles en la página web de [10X Genomics](https://support.10xgenomics.com/single-cell-atac/software/pipelines/latest/output/matrices): 

```{r, eval = F}
# El archivo con los datos crudos del ATAC-seq
download.file(
  "http://cf.10xgenomics.com/samples/cell-atac/1.1.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.h5", 
  destfile = "./archivos_accesorios/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.h5")

# Sus metadatos
download.file(
  "http://cf.10xgenomics.com/samples/cell-atac/1.1.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_singlecell.csv", 
  destfile = "./archivos_accesorios/atac_v1_adult_brain_fresh_5k_singlecell.csv")

# El archivo de los fragmentos
download.file(
  "http://cf.10xgenomics.com/samples/cell-atac/1.1.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz", 
  destfile = "./archivos_accesorios/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz")

# El archivo con el índice de los fragmentos
download.file(
  "http://cf.10xgenomics.com/samples/cell-atac/1.1.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz.tbi", 
  destfile = "./archivos_accesorios/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz.tbi")
```


<br>

Ahora cargamos las librerías que vamos a usar:

```{r, message=F, warning=F}
# Análisis
library("Signac")
library("Seurat")
# Genomas
library("GenomeInfoDb")
library("EnsDb.Mmusculus.v79")
# Gráficos
library("ggplot2")
library("patchwork")
set.seed(1234)
```




***

<br>

# Preprocesado

`Signac` requiere dos archivos generados por el software _CellRanger_ para poder preprocesar datos de ATAC-Seq:

* __Peak/Cell matrix o matriz de picos/célula__. La matriz de picos/célula es similar a la matriz de expresión génica de dimensiones _genes_ x _células_ usada en scRNA-Seq. En ATAC-Seq la matriz es de _regiones cromosómicas_ x _células_. Cada valor de la matriz es el nº de sitios de integración de Tn5 en cada célula que mapean en dichas regiones o _peaks_. A mayor nº de sitios de integración mapeados en un locus, más abierta está la cromatina en dicha región.

* __Fragment file o archivo de fragmentos__. Representa la lista completa de fragmentos únicos (= lecturas) detectados en todas las células y es por tanto un archivo MUY pesado. Al ser tan pesado, se guarda en el disco duro en lugar de la RAM y a consecuencia manipularlo es un proceso lento. Su ventaja es que contiene todos los sitios de integración de Tn5 en cada célula.


Ya que `Signac` es una extensión de `Seurat`, vamos a trabajar con un objeto `seurat` generado a partir de la __matriz de picos/célula__, sus __metadatos__ creados en `cellranger-atac` y el __archivo de fragmentos__:

```{r}
# Cargamos y visualizamos las 6 primeras filas de la matriz de ATAC_Seq en el
# objeto `matriz_picos_ATAC`:
matriz_picos_ATAC <- Read10X_h5(
  "E:/Git/R/Signac MB/archivos_accesorios/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.h5")

matriz_picos_ATAC[c(1:5), c(1:5)]


# Cargamos y exploramos el archivo de metadatos
metadatos <- read.csv(
  file = "E:/Git/R/Signac MB/archivos_accesorios/atac_v1_adult_brain_fresh_5k_singlecell.csv",
  header = TRUE,
  row.names = 1)

metadatos[c(1:5), c(1:5)]
dim(metadatos)
summary(metadatos)


# Creamos un objeto de tipo `ChromatinAssay`, necesario para generar el objeto
# de tipo `seurat`
ensayo_ATAC_Seq <- CreateChromatinAssay(
  counts = matriz_picos_ATAC,
  sep = c(":", "-"),
  genome = "mm10",
  fragments = "E:/Git/R/Signac MB/archivos_accesorios/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz",
  min.cells = 1)


# Finalmente creamos el objeto `seurat`
MB_Signac <- CreateSeuratObject(
  counts = ensayo_ATAC_Seq,
  assay = "peaks",
  project = "ATAC",
  meta.data = metadatos)


MB_Signac
MB_Signac[["peaks"]]
```


<br>

Los datos de la secuenciación ATAC se guardan en un objeto de tipo `ChromatinAssay`, el cual se caracteriza por presentar bolsillos para almacenar información adicional sobre motifs, anotaciones de los genes e información del genoma. A partir de dicho objeto creamos el principal objeto `seurat` donde realizaremos los análisis.  

Podemos usar la función `granges()` en un objeto de tipo `seurat` que tenga como experimento activo uno de tipo `ChromatinAssay` para observar las regiones cromosómicas (provenientes del archivo de fragmentos) asociadas a cada feature (gen?) del objeto. Para más información sobre la clase `ChromatinAssay`, consulte la [viñeta de interacción con objetos](https://satijalab.org/signac/articles/data_structures.html).


```{r}
# Exploración del ensayo/experimento de ATAC-Seq
ensayo_ATAC_Seq[1:5, 1:5]
dim(ensayo_ATAC_Seq) # Las columnas son las células secuenciadas y las filas son regiones cromosómicas... 5337 células y 157.203 regiones cromosómicas estudiadas
granges(MB_Signac)
```



<br>

También podemos añadir al objeto `MB_Signac` las anotaciones del genoma murino para que ciertos comandos puedan hacer uso de dicha información. 

```{r}
# Descargamos las anotaciones del genoma murino mm10 desde la base de datos
# Ensembl
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Mmusculus.v79)

# Las anotaciones están en formato NCBI. Vamos a cambiarlas al formato UCSC y
# especificaremos que estamos trabajando con el genoma mm10
seqlevelsStyle(annotations) <- "UCSC"
genome(annotations) <- "mm10"

# Añadimos las anotaciones al objeto `seurat`
Annotation(MB_Signac) <- annotations
Annotation(MB_Signac)
```

```{r, echo = F, eval = F}
seqinfo(MB_Signac)
MB_Signac@meta.data
annotations@elementMetadata
```





***

<br>

# Métricas de calidad (QC)


Ahora podemos comenzar con el control de calidad. Los desarrolladores de `Signac` recomiendan prestar atención a las siguientes métricas: 

 * __Nucleosome banding pattern__: El histograma de los tamaños de los fragmentos de ADN debe exhibir un marcado patrón de bandeo de nucleosomas correspondiente a la longitud del ADN enrollado alrededor de un único nucleosoma. Esta métrica se calcula mediante la siguiente ecuación:
 
$$nucleosome\ signal = \frac{fragmentos\_mononucleosomales}{fragmentos\_sin\_nucleosomas}$$

 * __Transcriptional start site (TSS) enrichment score__. El [proyecto ENCODE](https://www.encodeproject.org/data-standards/terms/) define el _TSS enrichment score_ como el ratio de fragmentos centrados en el TSS vs fragmentos flanqueantes al TSS. Los experimentos de ATAC-Seq mal hechos suelen tener un _TSS enrichment score_ bajo. Esta métrica se calcula para cada célula con el comando `TSSEnrichment()` y se almacena en los metadatos en la columna `TSS.enrichment`.

 * __Número total de fragmentos (= lecturas) en picos__: Las células con muy pocas lecturas se han secuenciado con poca profundidad, mientras que las células con muchas lecturas podrían ser _doublets_ (dos células secuenciadas como una), agregados de núcleos u otro tipo de artefactos. Por consiguiente se deben eliminar todas las células con valores extremos de lecturas en picos.

 * __Ratio de lecturas en picos__: Representa el porcentaje de fragmentos (_i.e._ regiones cromosómicas) que caen en picos. Las células con un ratio bajo (<15~20%) suelen ser células mal secuenciadas o artefactos técnicos (ruido) y por tanto se deberían eliminar. Tenga en cuenta que el umbral de rechazo de células depende del set de picos usado.

 * __Ratio de lecturas en regiones genómicas ruidosas (_blacklists_)__. El proyecto ENCODE también ha publicado para el genoma humano (hg19 y GRCh38) y otros una [lista negra](https://github.com/Boyle-Lab/Blacklist) de regiones cromosómicas que consiste en un listado de las lecturas normalmente asociadas a ruido técnico. Las células con un porcentaje elevado lecturas que mapeen a dichos loci suelen ser ruido y deben eliminarse. Las listas negras de ENCODE actualmente disponibles en `Signac` son para genoma humano(hg19 y GRCh38), ratón (mm10), Drosophila (dm3), y _C. elegans_ (ce10).

Téngase en cuenta que las métricas `Total number of fragments in peaks`, `Fraction of fragments in peaks` y `Ratio reads in genomic blacklist regions` pueden obtenerse del output de `CellRanger` de 10X Genomics. También es posible analizar datasets no provenientes de 10X Genomics gracias a las utilidades que incorpora `Signac`.



<br>

Calculamos la intensidad de la señal de los nucleosomas con el comando `NucleosomeSignal()`:

```{r}
MB_Signac <- NucleosomeSignal(object = MB_Signac)
```


Ahora podemos ver la distribución de la longitud de las lecturas en células con una _nucleosome signal_ < 4 (bueno) y > 4 (malo). Se aprecia que cada grupo de células tiene una distribución de fragmentos distinta. En las células bien secuenciadas (con un NS < 4), el primer pico de < 100pb se corresponde a los fragmentos sin nucleosomas (estas son lecturas de eucromatina, las cuales deberían mapear en los TSSs), el segundo pico se corresponde a lecturas provenientes de un nucleosoma o mononucleosoma (segundo pico entre 147pb y 147*2pb, flanquea regiones abiertas) y el tercer pico corresponde a lecturas dinucleosomas. Un buen ensayo de ATAC-Seq debe contener regiones libres dre nucleosomas, así como patrones de bandeos de nucleosomas, tal como se ve en nuestro caso en la gráfica NS < 4:

```{r}
MB_Signac$nucleosome_group <- ifelse(MB_Signac$nucleosome_signal > 4, "NS > 4", "NS < 4")
FragmentHistogram(object = MB_Signac, group.by = "nucleosome_group", region = "chr1-1-10000000")
```



<br>

El enriquecimiento de eventos de integración de la Tn5 en los TSSs es también una importante métrica de control de calidad. El consorcio ENCODE define la puntuación de enriquecimiento de TSSs como el nº de sitios de integración de la Tn5 alrededor del sitio de comienzo de la transcripción normalizado por el nº de sitios de integración de la TN5 en regiones flanqueantes al TSS (hasta 2000pb aguas arriba y aguas abajo, respectivamente). 

En `Signac` calculamos la puntuación de enriquecimiento de los TSSs con el comando `TSSEnrichment()`. Si usamos el parámetro `fast = T`, calcularemos sólo la puntuación de enriquecimiento de los TSSs y ahorraremos tiempo y memoria, pero no computaremos la matriz necesaria para visualizar dicho enriquecimiento mediante la función `TSSPlot()`. El significado del valor del enriquecimiento de TSSs depende del genoma que estemos analizando. De acuerdo al [proyecto ENCODE](https://www.encodeproject.org/atac-seq/), para el genoma mm10 valores < 10 son malos; valores ente 10 y 15 son aceptables y valores > 15 son ideales. En nuestro caso vemos que el enriquecimiento de nuestras células alrededor del TSS está entre 10 y 15, por lo que el experimento en cuestión es válido.

```{r}
MB_Signac <- TSSEnrichment(MB_Signac, fast = F)  
MB_Signac$high.tss <- ifelse(MB_Signac$TSS.enrichment > 2, "High", "Low")
TSSPlot(MB_Signac, group.by = "high.tss") + NoLegend()
```


<br>

Habiendo calculado ya el _TSS enrichment score_ y el _nucleosome signal_, procedemos a calcular el ratio de lecturas que mapean en picos y el ratio de lecturas que caen en regiones prohibidas y mostramos todas estas métricas de calidad en gráficos de violín para analizar la calidad de nuestro experimento:

```{r}
MB_Signac$pct_reads_in_peaks <- MB_Signac$peak_region_fragments / MB_Signac$passed_filters * 100
MB_Signac$blacklist_ratio <- MB_Signac$blacklist_region_fragments / MB_Signac$peak_region_fragments


VlnPlot(object = MB_Signac,
        features = c("pct_reads_in_peaks", "peak_region_fragments",
                   "TSS.enrichment", "blacklist_ratio", "nucleosome_signal"),
        pt.size = 0.1,
        ncol = 5)
```


Concluimos la sección de QC eliminando las células que no cumplan con los estándares de calidad. Para ello nos quedaremos con aquellas células que cumplan las siguientes condiciones:

* Contener entre 3000 y 100000 lecturas que mapeen en picos

* Un ratio de lecturas en picos > 40%

* Un porcentaje de lecturas en regiones genómicas ruidosas < 0.025%

* Una señal de nucleosoma < 4

* Una puntuación de enriquecimiento de TSSs > 2

```{r}
MB_Signac <- subset(
  x = MB_Signac,
  subset = peak_region_fragments > 3000 &
    peak_region_fragments < 100000 &
    pct_reads_in_peaks > 40 &
    blacklist_ratio < 0.025 &
    nucleosome_signal < 4 &
    TSS.enrichment > 2)

MB_Signac
```



***

<br>

## Normalizado y reducción lineal de la dimensionalidad (LSI)

Para el normalizado, `Signac` realiza una técnica de dos pasos denominada TF-IDF o _Term Frequency - Inverse Document Frequency_, la cual por un lado normaliza las células (para corregir las posibles diferencias en la profundidad de secuenciado entre células) y por otro normaliza los picos (para dar más importancia a los picos poco comunes).

Si estuviésemos analizando un experimento de scRNA-Seq con `Seurat`, haríamos una selección de características (=genes) después del normalizado, pero en scATAC-Seq es más difícil realizar dicha selección debido al bajo rango dinámico de estos datos (i.e. bajo ratio señal/ruido). En este caso podemos usar el top x% de picos (=regiones cromosómicas) variables para la reducción de la dimensionalidad, o eliminar los picos que estén presentes en menos de x células (usando para ello el comando `FindTopFeatures()`). Nosotros usaremos el top 25% (`min.cutoff = "q75"`).

Para la reducción de la dimensionalidad, realizamos una técnica matemática denominada SVD o _Singular Value Decomposition_ sobre la matriz devuelta por el TD-IDF (el SVD se realiza también para generar PCAs) y usando sólo los picos seleccionados en el paso previo. Llamamos LSI o _latent semantic indexing_ a la técnica que combina un paso de TF-IDF seguido de un paso de SVD, y fue usado exitósamente por primera vez en el análisis de scATAC-seq por [Cusanovich _et al._, 2015](https://www.science.org/doi/abs/10.1126/science.aax6234).


```{r}
MB_Signac <- RunTFIDF(MB_Signac) # Normalizado
MB_Signac <- FindTopFeatures(MB_Signac, min.cutoff = 'q75') # Selección de características
MB_Signac <- RunSVD(MB_Signac) # Reducción de la dimensionalidad
```


<br>

La primera componente del LSI suele capturar la profundidad del secuenciado (variación técnica) y no varianza biológica. Si ese es el caso, esta componente de debe eliminar de los próximos análisis. Podemos observar la correlación entre cada componente del LSI y la profundidad de secuenciado con la función `DepthCor()`:

```{r}
DepthCor(MB_Signac)
```

Se aprecia que la primera componente del LSI está inversamente muy correlacionada (R ≈ -1) con el nº total de lecturas en células, por lo que omitiremos esta componente en los próximos análisis.



***

<br>

# Reducción no lineal de la dimensionalidad y clustering

Con las células embebidas en el LSI, podemos agruparlas
Now that the cells are embedded in a low-dimensional space, we can use methods commonly applied for the analysis of scRNA-seq data to perform graph-based clustering and non-linear dimension reduction for visualization. The functions RunUMAP(), FindNeighbors(), and FindClusters() all come from the Seurat package.

Nótese que omitiremos la primera componente del LSI (`dims = 2:30`)

```{r}
MB_Signac <- RunUMAP(MB_Signac, reduction = "lsi", dims = 2:30)
MB_Signac <- FindNeighbors(MB_Signac, reduction = "lsi", dims = 2:30)
MB_Signac <- FindClusters(MB_Signac, algorithm = 3, resolution = 1.2, 
                          verbose = F)
DimPlot(MB_Signac, label = TRUE) + NoLegend()
```




```{r}
cov_plot <- CoveragePlot(
  object = MB_Signac,
  region = "chr2-87011729-87035519",
  annotation = FALSE,
  peaks = FALSE
)

cov_plot
```


***

<br>

# Create a gene activity matrix



```{r}
# compute gene activities
gene.activities <- GeneActivity(MB_Signac)

# add the gene activity matrix to the Seurat object as a new assay
MB_Signac[['RNA']] <- CreateAssayObject(counts = gene.activities)
MB_Signac <- NormalizeData(
  object = MB_Signac,
  assay = 'RNA',
  normalization.method = 'LogNormalize',
  scale.factor = median(MB_Signac$nCount_RNA)
)
```



```{r}
DefaultAssay(MB_Signac) <- 'RNA'
FeaturePlot(
  object = MB_Signac,
  features = c('Sst','Pvalb',"Gad2","Neurod6","Rorb","Syt6"),
  pt.size = 0.1,
  max.cutoff = 'q95',
  ncol = 3
)
```


***

<br>

# Integrating with scRNA-seq data


[PH]

```{r}
# Load the pre-processed scRNA-seq data
allen_rna <- readRDS("./archivos_accesorios/allen_brain.rds")
allen_rna <- FindVariableFeatures(
  object = allen_rna,
  nfeatures = 5000
)

transfer.anchors <- FindTransferAnchors(
  reference = allen_rna,
  query = MB_Signac,
  reduction = 'cca',
  dims = 1:40
)

predicted.labels <- TransferData(
  anchorset = transfer.anchors,
  refdata = allen_rna$subclass,
  weight.reduction = MB_Signac[['lsi']],
  dims = 2:30
)

MB_Signac <- AddMetaData(object = MB_Signac, metadata = predicted.labels)
```



```{r}
plot1 <- DimPlot(allen_rna, group.by = 'subclass', label = TRUE, repel = TRUE) + NoLegend() + ggtitle('scRNA-seq')
plot2 <- DimPlot(MB_Signac, group.by = 'predicted.id', label = TRUE, repel = TRUE) + NoLegend() + ggtitle('scATAC-seq')
plot1 + plot2
```



<details>


<summary> __Why did we change default parameters?__</summary>


</details>


```{r}
# replace each label with its most likely prediction
for(i in levels(MB_Signac)) {
  cells_to_reid <- WhichCells(MB_Signac, idents = i)
  newid <- names(sort(table(MB_Signac$predicted.id[cells_to_reid]),decreasing=TRUE))[1]
  Idents(MB_Signac, cells = cells_to_reid) <- newid
}
```


***

<br>

# Find differentially accessible peaks between clusters



[PH]


```{r}
#switch back to working with peaks instead of gene activities
DefaultAssay(MB_Signac) <- 'peaks'

da_peaks <- FindMarkers(
  object = MB_Signac,
  ident.1 = c("L2/3 IT"), 
  ident.2 = c("L4", "L5 IT", "L6 IT"),
  min.pct = 0.05,
  test.use = 'LR',
  latent.vars = 'peak_region_fragments'
)

head(da_peaks)
```




```{r}
plot1 <- VlnPlot(
  object = MB_Signac,
  features = rownames(da_peaks)[1],
  pt.size = 0.1,
  idents = c("L4","L5 IT","L2/3 IT")
)
plot2 <- FeaturePlot(
  object = MB_Signac,
  features = rownames(da_peaks)[1],
  pt.size = 0.1,
  max.cutoff = 'q95'
)
plot1 | plot2
```





```{r}
open_l23 <- rownames(da_peaks[da_peaks$avg_log2FC > 0.25, ])
open_l456 <- rownames(da_peaks[da_peaks$avg_log2FC < -0.25, ])
closest_l23 <- ClosestFeature(MB_Signac, open_l23)
closest_l456 <- ClosestFeature(MB_Signac, open_l456)
head(closest_l23)
```




```{r}
head(closest_l456)
```


***

<br>

# Plotting genomic regions


placeholder



```{r}
# set plotting order
levels(MB_Signac) <- c("L2/3 IT","L4","L5 IT","L5 PT","L6 CT", "L6 IT","NP","Sst","Pvalb","Vip","Lamp5","Meis2","Oligo","Astro","Endo","VLMC","Macrophage")

CoveragePlot(
  object = MB_Signac,
  region = c("Neurod6", "Gad2"),
  extend.upstream = 1000,
  extend.downstream = 1000,
  ncol = 1
)
```


***

<br>

# Bibliografía

* Stuart _et al._ Multimodal single-cell chromatin analysis with Signac. bioRxiv (2020).

* [PH]

* [PH]

* [PH]




***

<br>

# sessionInfo()

<details>

<summary> __Click para mostrar__ </summary>

```{r, echo = F}
sessionInfo()
```

</details>