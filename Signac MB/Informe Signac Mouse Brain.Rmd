---
title: "Análisis de datos scATAC-seq en Signac: cerebro murino"
author: "Adam Casas"
date: 'Compilado: `r format(Sys.Date(), "%d de %B del %Y")`'
output: 
  html_document:
    df_print: paged
    highlight: kate
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_float: yes
---

```{r configuracion_inicial, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = F,
                      warning = F)
set.seed(1)
##################################################
#######        Encoded in UTF-8        ###########
##################################################
```

```{r Paralelizado future, echo = F}
library("future")
# Establecemos las semillas aleatorias de `future` para evitar que dé problemas
# el comando `FindClusters()`
options("future.seed" = T) 
# Establecemos el límite de tamaño que puede usar `future` en 2 GBs dado que de
# lo contrario superamos el límite por defecto de 500 MBs/hilo al trabajar con
# objetos tan grandes
plan(strategy = "multisession", workers = 4)
options(future.globals.maxSize = 4 * 512^3)
```


***

# Instalación

Instalamos `Signac` en R versión 4.1:

```{r, eval = F}
BiocManager::install("Rsamtools")
install.packages("Signac")
```



***

<br>

# Introducción

`Signac` (Stuart _et al._, 2020) es una extensión del famoso paquete `Seurat` para explorar, analizar e interpretar datasets de scATAC-seq. ATAC-seq (y su variante de célula única) es, por decirlo de alguna manera, la sucesora espiritural de técnicas de secuenciación como ChIP-seq y RRBS-Seq (un tipo de secuenciación por bisulfito). Si en dichas técnicas se estudia el estado epigenético de las células/tejidos de interés, cierto es que se debe tener un conocimiento previo de cómo funcionan los mecanismos epigenéticos del organismo en cuestión para poder sacarles el mayor rendimiento. __ATAC-seq__, por otro lado, evade dicha imposición al estudiar directamente la __accesibilidad de la cromatina__ a la transposasa hiperactiva Tn5 de manera "agnóstica" (sin necesidad de conocer _a priori_ los mecanismos epigenéticos subyacentes).


En este informe vamos a presentar `Signac` mediante el análisis de un dataset compuesto por 5000 células provenientes de la corteza visual primaria de cerebros de ratones adultos. Para ello debemos descargar primero los siguientes archivos, disponibles en la página web de [10X Genomics](https://support.10xgenomics.com/single-cell-atac/software/pipelines/latest/output/matrices): 

```{r, eval = F}
# El archivo con los datos crudos del ATAC-seq
download.file(
  "http://cf.10xgenomics.com/samples/cell-atac/1.1.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.h5", 
  destfile = "./archivos_accesorios/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.h5")

# Sus metadatos
download.file(
  "http://cf.10xgenomics.com/samples/cell-atac/1.1.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_singlecell.csv", 
  destfile = "./archivos_accesorios/atac_v1_adult_brain_fresh_5k_singlecell.csv")

# El archivo de los fragmentos
download.file(
  "http://cf.10xgenomics.com/samples/cell-atac/1.1.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz", 
  destfile = "./archivos_accesorios/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz")

# El archivo con el índice de los fragmentos
download.file(
  "http://cf.10xgenomics.com/samples/cell-atac/1.1.0/atac_v1_adult_brain_fresh_5k/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz.tbi", 
  destfile = "./archivos_accesorios/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz.tbi")
```


<br>

Ahora cargamos las librerías que vamos a usar:

```{r, message=F, warning=F}
# Análisis
library("Signac")
library("Seurat")
# Genomas
library("GenomeInfoDb")
library("EnsDb.Mmusculus.v79")
# Gráficos
library("ggplot2")
library("patchwork")
```




***

<br>

# Preprocesado

`Signac` requiere dos archivos generados por el software _CellRanger_ para poder preprocesar datos de ATAC-Seq (aunque al final del informe se muestra cómo actuar si los archivos de secuenciado se generaron con un software distinto):

* __Peak/Cell matrix o matriz de picos/célula__. La matriz de picos/célula es similar a la matriz de expresión génica de dimensiones _genes_ x _células_ usada en scRNA-Seq. En ATAC-Seq la matriz es de _regiones cromosómicas_ x _células_. Cada valor de la matriz es el nº de sitios de integración de Tn5 en cada célula que mapean en dichas regiones o _peaks_. A mayor nº de sitios de integración mapeados en un locus, más abierta está la cromatina en dicha región.

* __Fragment file o archivo de fragmentos__. Representa la lista completa de fragmentos únicos (= lecturas) detectados en todas las células y es por tanto un archivo MUY pesado. Al ser tan pesado, se guarda en el disco duro en lugar de la RAM y a consecuencia manipularlo es un proceso lento. Su ventaja es que contiene todos los sitios de integración de Tn5 en cada célula.


Ya que `Signac` es una extensión de `Seurat`, vamos a trabajar con un objeto `seurat` generado a partir de la __matriz de picos/célula__, sus __metadatos__ creados en `cellranger-atac` y el __archivo de fragmentos__:

```{r}
# Cargamos y visualizamos las 6 primeras filas de la matriz de ATAC_Seq en el
# objeto `matriz_picos_ATAC`:
matriz_picos_ATAC <- Read10X_h5(
  "E:/Git/R/Signac MB/archivos_accesorios/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.h5")

matriz_picos_ATAC[c(1:5), c(1:5)]


# Cargamos y exploramos el archivo de metadatos
metadatos <- read.csv(
  file = "E:/Git/R/Signac MB/archivos_accesorios/atac_v1_adult_brain_fresh_5k_singlecell.csv",
  header = TRUE,
  row.names = 1)

metadatos[c(1:5), c(1:5)]
dim(metadatos)
summary(metadatos)


# Creamos un objeto de tipo `ChromatinAssay`, necesario para generar el objeto
# de tipo `seurat`
ensayo_ATAC_Seq <- CreateChromatinAssay(
  counts = matriz_picos_ATAC,
  sep = c(":", "-"),
  genome = "mm10",
  fragments = "E:/Git/R/Signac MB/archivos_accesorios/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz",
  min.cells = 1)


# Finalmente creamos el objeto `seurat`
MB_Signac <- CreateSeuratObject(
  counts = ensayo_ATAC_Seq,
  assay = "peaks",
  project = "ATAC",
  meta.data = metadatos)


MB_Signac
MB_Signac[["peaks"]]
```


<br>

Los datos de la secuenciación ATAC se guardan en un objeto de tipo `ChromatinAssay`, el cual se caracteriza por presentar bolsillos para almacenar información adicional sobre motifs, anotaciones de los genes e información del genoma. A partir de dicho objeto creamos el principal objeto `seurat` donde realizaremos los análisis.  

Podemos usar la función `granges()` en un objeto de tipo `seurat` que tenga como experimento activo uno de tipo `ChromatinAssay` para observar las regiones cromosómicas (provenientes del archivo de fragmentos) asociadas a cada gen del objeto. Para más información sobre la clase `ChromatinAssay`, consulte la [viñeta de interacción con objetos](https://satijalab.org/signac/articles/data_structures.html).


```{r}
# Exploración del ensayo/experimento de ATAC-Seq
ensayo_ATAC_Seq[1:5, 1:5]
# Las columnas son las células secuenciadas y las filas son regiones
# cromosómicas... 5337 células y 157.203 regiones cromosómicas estudiadas
dim(ensayo_ATAC_Seq) 
granges(MB_Signac)
```



<br>

También podemos añadir al objeto `MB_Signac` las anotaciones del genoma murino para que ciertos comandos puedan hacer uso de dicha información. 

```{r, warning = F}
# Descargamos las anotaciones del genoma murino mm10 desde la base de datos
# Ensembl
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Mmusculus.v79, verbose = F)

# Las anotaciones están en formato NCBI. Vamos a cambiarlas al formato UCSC y
# especificaremos que estamos trabajando con el genoma mm10
seqlevelsStyle(annotations) <- "UCSC"
genome(annotations) <- "mm10"

# Añadimos las anotaciones al objeto `seurat`
Annotation(MB_Signac) <- annotations
Annotation(MB_Signac)
```

```{r, echo = F, eval = F}
seqinfo(MB_Signac)
MB_Signac@meta.data
annotations@elementMetadata
```





***

<br>

# Métricas de calidad (QC)


Ahora podemos comenzar con el control de calidad. Los desarrolladores de `Signac` recomiendan prestar atención a las siguientes métricas: 

 * __Nucleosome banding pattern__: El histograma de los tamaños de los fragmentos de ADN debe exhibir un marcado patrón de bandeo de nucleosomas correspondiente a la longitud del ADN enrollado alrededor de un único nucleosoma. Esta métrica se calcula mediante la siguiente ecuación:
 
$$nucleosome\ signal = \frac{fragmentos\_mononucleosomales}{fragmentos\_sin\_nucleosomas}$$

 * __Transcriptional start site (TSS) enrichment score__. El [proyecto ENCODE](https://www.encodeproject.org/data-standards/terms/) define el _TSS enrichment score_ como el ratio de fragmentos centrados en el TSS vs fragmentos flanqueantes al TSS. Los experimentos de ATAC-Seq mal hechos suelen tener un _TSS enrichment score_ bajo. Esta métrica se calcula para cada célula con el comando `TSSEnrichment()` y se almacena en los metadatos en la columna `TSS.enrichment`.

 * __Número total de fragmentos (= lecturas) en picos__: Las células con muy pocas lecturas se han secuenciado con poca profundidad, mientras que las células con muchas lecturas podrían ser _doublets_ (dos células secuenciadas como una), agregados de núcleos u otro tipo de artefactos. Por consiguiente se deben eliminar todas las células con valores extremos de lecturas en picos.

 * __Ratio de lecturas en picos__: Representa el porcentaje de fragmentos (_i.e._ regiones cromosómicas) que caen en picos. Las células con un ratio bajo (<15~20%) suelen ser células mal secuenciadas o artefactos técnicos (ruido) y por tanto se deberían eliminar. Tenga en cuenta que el umbral de rechazo de células depende del set de picos usado.

 * __Ratio de lecturas en regiones genómicas ruidosas (_blacklists_)__. El proyecto ENCODE también ha publicado para el genoma humano (hg19 y GRCh38) y otros una [lista negra](https://github.com/Boyle-Lab/Blacklist) de regiones cromosómicas que consiste en un listado de las lecturas normalmente asociadas a ruido técnico. Las células con un porcentaje elevado lecturas que mapeen a dichos loci suelen ser ruido y deben eliminarse. Las listas negras de ENCODE actualmente disponibles en `Signac` son para genoma humano(hg19 y GRCh38), ratón (mm10), Drosophila (dm3), y _C. elegans_ (ce10).

Téngase en cuenta que las métricas `Total number of fragments in peaks`, `Fraction of fragments in peaks` y `Ratio reads in genomic blacklist regions` pueden obtenerse del output de `CellRanger` de 10X Genomics. También es posible analizar datasets no provenientes de 10X Genomics gracias a las utilidades que incorpora `Signac`.



<br>

Calculamos la intensidad de la señal de los nucleosomas con el comando `NucleosomeSignal()`:

```{r}
MB_Signac <- NucleosomeSignal(object = MB_Signac)
```


Ahora podemos ver la distribución de la longitud de las lecturas en células con una _nucleosome signal_ < 4 (bueno) y > 4 (malo). Se aprecia que cada grupo de células tiene una distribución de fragmentos distinta. En las células bien secuenciadas (con un NS < 4), el primer pico de < 100pb se corresponde a los fragmentos sin nucleosomas (estas son lecturas de eucromatina, las cuales deberían mapear en los TSSs), el segundo pico se corresponde a lecturas provenientes de un nucleosoma o mononucleosoma (segundo pico entre 147pb y 147*2pb, flanquea regiones abiertas) y el tercer pico corresponde a lecturas dinucleosomas. Un buen ensayo de ATAC-Seq debe contener regiones libres dre nucleosomas, así como patrones de bandeos de nucleosomas, tal como se ve en nuestro caso en la gráfica NS < 4:

```{r}
MB_Signac$nucleosome_group <- ifelse(MB_Signac$nucleosome_signal > 4, "NS > 4", "NS < 4")
FragmentHistogram(object = MB_Signac, group.by = "nucleosome_group", region = "chr1-1-10000000")
```



<br>

El enriquecimiento de eventos de integración de la Tn5 en los TSSs es también una importante métrica de control de calidad. El consorcio ENCODE define la puntuación de enriquecimiento de TSSs como el nº de sitios de integración de la Tn5 alrededor del sitio de comienzo de la transcripción normalizado por el nº de sitios de integración de la TN5 en regiones flanqueantes al TSS (hasta 2000pb aguas arriba y aguas abajo, respectivamente). 

En `Signac` calculamos la puntuación de enriquecimiento de los TSSs con el comando `TSSEnrichment()`. Si usamos el parámetro `fast = T`, calcularemos sólo la puntuación de enriquecimiento de los TSSs y ahorraremos tiempo y memoria, pero no computaremos la matriz necesaria para visualizar dicho enriquecimiento mediante la función `TSSPlot()`. El significado del valor del enriquecimiento de TSSs depende del genoma que estemos analizando. De acuerdo al [proyecto ENCODE](https://www.encodeproject.org/atac-seq/), para el genoma mm10 valores < 10 son malos; valores ente 10 y 15 son aceptables y valores > 15 son ideales. En nuestro caso vemos que el enriquecimiento de nuestras células alrededor del TSS está entre 10 y 15, por lo que el experimento en cuestión es válido.

```{r}
MB_Signac <- TSSEnrichment(MB_Signac, fast = F)  
MB_Signac$high.tss <- ifelse(MB_Signac$TSS.enrichment > 2, "High", "Low")
TSSPlot(MB_Signac, group.by = "high.tss") + NoLegend()
```


<br>

Habiendo calculado ya el _TSS enrichment score_ y el _nucleosome signal_, procedemos a calcular el ratio de lecturas que mapean en picos y el ratio de lecturas que caen en regiones prohibidas y mostramos todas estas métricas de calidad en gráficos de violín para analizar la calidad de nuestro experimento:

```{r, fig.width =  12}
MB_Signac$pct_reads_in_peaks <- MB_Signac$peak_region_fragments / MB_Signac$passed_filters * 100
MB_Signac$blacklist_ratio <- MB_Signac$blacklist_region_fragments / MB_Signac$peak_region_fragments


VlnPlot(object = MB_Signac,
        features = c("pct_reads_in_peaks", "peak_region_fragments",
        "TSS.enrichment","blacklist_ratio", "nucleosome_signal"),
        pt.size = 0.1,
        ncol = 5)
```


Concluimos la sección de QC eliminando las células que no cumplan con los estándares de calidad. Para ello nos quedaremos con aquellas células que cumplan las siguientes condiciones:

* Contener entre 3000 y 100000 lecturas que mapeen en picos

* Un ratio de lecturas en picos > 40%

* Un porcentaje de lecturas en regiones genómicas ruidosas < 0.025%

* Una señal de nucleosoma < 4

* Una puntuación de enriquecimiento de TSSs > 2

```{r}
MB_Signac <- subset(
  x = MB_Signac,
  subset = peak_region_fragments > 3000 &
    peak_region_fragments < 100000 &
    pct_reads_in_peaks > 40 &
    blacklist_ratio < 0.025 &
    nucleosome_signal < 4 &
    TSS.enrichment > 2)

MB_Signac
```



***

<br>

## Normalizado y reducción lineal de la dimensionalidad (LSI)

Para el normalizado, `Signac` realiza una técnica de dos pasos denominada TF-IDF o _Term Frequency - Inverse Document Frequency_, la cual por un lado normaliza las células (para corregir las posibles diferencias en la profundidad de secuenciado entre células) y por otro normaliza los picos (para dar más importancia a los picos poco comunes).

Si estuviésemos analizando un experimento de scRNA-Seq con `Seurat`, haríamos una selección de características (=genes) después del normalizado, pero en scATAC-Seq es más difícil realizar dicha selección debido al bajo rango dinámico de estos datos (i.e. bajo ratio señal/ruido). En este caso podemos usar el top x% de picos (=regiones cromosómicas) variables para la reducción de la dimensionalidad, o eliminar los picos que estén presentes en menos de x células (usando para ello el comando `FindTopFeatures()`). Nosotros usaremos el top 25% (`min.cutoff = "q75"`).

Para la reducción de la dimensionalidad, realizamos una técnica matemática denominada SVD o _Singular Value Decomposition_ sobre la matriz devuelta por el TD-IDF (el SVD se realiza también para generar PCAs) y usando sólo los picos seleccionados en el paso previo. Llamamos LSI o _latent semantic indexing_ a la técnica que combina un paso de TF-IDF seguido de un paso de SVD, y fue usado exitósamente por primera vez en el análisis de scATAC-seq por [Cusanovich _et al._, 2015](https://www.science.org/doi/abs/10.1126/science.aax6234).


```{r}
MB_Signac <- RunTFIDF(MB_Signac) # Normalizado
MB_Signac <- FindTopFeatures(MB_Signac, min.cutoff = 'q75') # Selección de características
MB_Signac <- RunSVD(MB_Signac) # Reducción de la dimensionalidad
```


<br>

La primera componente del LSI suele capturar la profundidad del secuenciado (variación técnica) y no la varianza biológica. Si ese es el caso, esta componente de debe eliminar de los próximos análisis. Podemos observar la correlación entre cada componente del LSI y la profundidad de secuenciado con la función `DepthCor()`:

```{r}
DepthCor(MB_Signac)
```

<br>

Se aprecia que la primera componente del LSI está inversamente muy correlacionada (R ≈ -1) con el nº total de lecturas en células, por lo que omitiremos esta componente en los próximos análisis. Por último, graficamos el LSI, omitiendo la primera componente. El output del mismo recuerda al de un PCA en el sentido de que parece ser una reducción lineal de la dimensionalidad:

```{r}
DimPlot(object = MB_Signac, label = TRUE, reduction = "lsi", dims = c(2,3)) + NoLegend()
```


***

<br>

# Reducción no lineal de la dimensionalidad y clustering

Con las células embebidas en el LSI, podemos agruparlas mediante las técnicas ya aprendidas en los protocolos de `Seurat` (clustering basado en grafos) y posteriormente visualizarlas con un t-SNE o un UMAP. Este paso es por tanto exactamente igual que en anteriores _workflows_ para scRNA-Seq ya mostrados, con la salvedad de que omitiremos la primera componente del LSI (`dims = 2:30`).

```{r}
MB_Signac <- FindNeighbors(MB_Signac, reduction = "lsi", dims = 2:30)
MB_Signac <- FindClusters(MB_Signac, algorithm = 3, resolution = 1.2, 
                          verbose = F)
MB_Signac <- RunUMAP(MB_Signac, reduction = "lsi", dims = 2:30)
DimPlot(MB_Signac, reduction = "umap", label = TRUE) + NoLegend()
```




***

<br>

# Matriz de actividad génica


En el UMAP apreciamos la presencia de hasta 21 clusters, los cuales se corresponden con estirpes celulares presentes en el cerebro de ratones adultos. Por desgracia, anotar estos clusters no es tan fácil en ATAC-seq dado que a diferencia de RNA-seq (que se centra en genes), a día de hoy se sabe poco sobre el rol de las regiones genómicas no codificantes.

No obstante, podemos inferir la actividad de cada gen en el genoma a través de la accesibilidad de la cromatina asociada a dichos ORFs y crear así un nuevo ensayo para nuestro objeto `seurat` derivado del experimento de scATAC-seq. Una manera sencilla de lograrlo es sumar los fragmentos que caigan en la región promotora o en el ORF del gen en cuestión, aunque también es posible integrar en un worflow de `Signac` la herramienta [Cicero](https://cole-trapnell-lab.github.io/cicero-release/), desarrollada por el autor de `Monocle3` (otro paquete integrable en workflows de `Seurat`), Cole Trapnell.

Para generar una matriz de actividad génica extraemos las coordenadas de los genes, las extendemos 2kb aguas arriba (para incluir al promotor) y a continuación contamos para cada célula el nº de lecturas que mapean en dichas regiones usando la función `FeatureMatrix()`. Estos pasos se realizan automáticamente al invocar al comando `GeneActivity()`. El objetivo de esta actividad es inferir una matriz de conteos capaz de poder ser usada como input para un nuevo ensayo, como si hubiésemos secuenciado el transcriptoma de estas células:

```{r}
# Generamos la matriz de actividad génica
matriz_act_gen <- GeneActivity(MB_Signac)

# Añadimos dicha matriz a nuestro objeto `seurat` en forma de un nuevo ensayo de
# scRNA-seq y normalizamos los datos
MB_Signac[["RNA"]] <- CreateAssayObject(counts = matriz_act_gen)

MB_Signac <- NormalizeData(object = MB_Signac, assay = "RNA", 
                           normalization.method = "LogNormalize", 
                           scale.factor = median(MB_Signac$nCount_RNA))
```


<br>

Ahora somos capaces de visualizar la actividad de biomarcadores canónicos para guiar nuestra interpretación de los clusters de scATAC-seq, si bien este nuevo experimento putativo de "scRNA-seq" derivado de scATAC-seq será más ruidoso que uno canónico de scRNA-seq, pero nos servirá. Dicho ruido se debe a que al generar la matriz de actividad génica asumimos una correlación perfecta entre accesibilidad del promotor/ORF y expresión génica, lo cual a veces no es así.

```{r,fig.width = 10}
DefaultAssay(MB_Signac) <- "RNA"

FeaturePlot(object = MB_Signac,
            features = c("Sst", "Pvalb", "Gad2", "Neurod6", "Rorb", "Syt6"),
            pt.size = 0.1, max.cutoff = 'q95', ncol = 3)
```



***

<br>

# Integración multiómica/multimodal (scRNA-seq)

Para ayudarnos más aún con la intepretación de los clusters de scATAC-seq, podemos clasificar las células basándonos en un experimento real de scRNA-seq del mismo tipo de tejido. Para combinar datos de ATAC-seq y RNA-seq, `Signac` (y `Seurat`) usa los métodos de integración multiómicos y transferencia de etiquetas descritos en este [paper](https://doi.org/10.1016/j.cell.2019.05.031). El objetivo es identificar patrones de correlación compartidos entre la matriz de actividad génica generada en el apartado anterior y un dataset anotado de scRNA-seq para descubrir tipos celulares compatidos entre ambas ómicas. Este procedimiento se realiza mediante un CCA (procedimiento descrito en otros workflows de `Seurat` y en la traducción de Seurat 2 a Seurat 3, [3ª práctica](https://github.com/gloknar/R/blob/master/Traduccion%20Seurat%20V2%20V3/Informe%20practica%203.Rmd)), y devuelve una puntuación de clasificación para cada célula de los clusters anotados en el experimento real de scRNA-seq.

Para el experimento real de scRNA-seq, puedes descargar los [datos crudos](http://celltypes.brain-map.org/api/v2/well_known_file_download/694413985) en la página del Allen Institute y preprocesarlos con `Seurat`, o bien [descargar](https://www.dropbox.com/s/kqsy9tvsklbu7c4/allen_brain.rds?dl=0) el objeto `seurat` ya preprocesado. Para preprocesar los datos, se usó este [script](https://github.com/satijalab/Integration2019/blob/master/preprocessing_scripts/allen_brain.R). Para este ensayo se secuenciaron cerebros de varios ratones con distintos genotipos (concretamente la corteza visual primaria).

```{r}
# Cargamos el ensayo de scRNA-seq (objeto tipo `seurat`) del Instituto Allen
allen_rna <- readRDS("./archivos_accesorios/allen_brain.rds")

# Ampliamos el nº de genes diferencialmente expresados a 5000
allen_rna <- FindVariableFeatures(object = allen_rna, nfeatures = 5000)

# Detectamos células ancla en nuestros datasets mediante un CCA/RCPA
transfer.anchors <- FindTransferAnchors(reference = allen_rna, query = MB_Signac, 
                                        reduction = "rpca", dims = 1:40) 
# Nota: ya que usamos datasets pesados, no divergentes (mirar UMAP) y de la
# misma especie, es computacionalmente más eficiente usar un RCPA en vez de un
# CCA

# Predecimos los tipos celulares presentes en el ensayo de scATAC-seq usando
# como input las células ancla y el dataset del Instituto Allen como referencia
predicted.labels <- TransferData(
  anchorset = transfer.anchors, 
  refdata = allen_rna$subclass, 
  weight.reduction = MB_Signac[["lsi"]], # reducción de dim. del objeto `seurat` original
  dims = 2:30)

# Añadimos a los metadatos del objeto principal `MB_Signac` las predicciones
# sobre los tipos celulares y sustituimos las etiquetas antiguas por estas
# nuevas
MB_Signac <- AddMetaData(object = MB_Signac, metadata = predicted.labels)

for(i in levels(MB_Signac)) {
  cells_to_relabel <- WhichCells(MB_Signac, idents = i)
  newid <- names(sort(table(MB_Signac$predicted.id[cells_to_relabel]),decreasing=TRUE))[1]
  Idents(MB_Signac, cells = cells_to_relabel) <- newid
}
```



```{r, fig.width = 14}
plot1 <- DimPlot(allen_rna, group.by = "subclass", label = TRUE) + NoLegend() + ggtitle("scRNA-seq (Allen Inst., anotado)")
plot2 <- DimPlot(MB_Signac, group.by = "predicted.id", label = TRUE) + NoLegend() + ggtitle("scATAC-seq (predicción)")
plot3 <- DimPlot(MB_Signac, label = T, group.by = "ident") + NoLegend() + ggtitle("scATAC-seq (anot. Allen)")
plot1 + plot2 + plot3
```


<br>

Se aprecia que aunque las visualizaciones de scRNA-seq y scATAC-seq no son exactamente iguales, la agrupación de los clusters es consistente entre ambos ensayos (por ejemplo, las neuronas productoras de somatostatina `Sst` y las interneuronas productoras de parvalbúmina `Pvalb` forman clusters adyacentes en ambos experimentos).






***

<br>

# Detección de biomarcadores de clusters (regiones cromosómicas diferencialmente accesibles)


Si en estudios de transcriptómica analizamos los genes diferencialmente transcribidos, es lógico estudiar en ATAC-seq aquellas regiones del genoma que son diferencialmente accesibles a la transposasa Tn5. Para estudiar la apertura diferencial de la cromatina se usan regresiones logísticas, tal como recomienda [Ntranos _et al._ 2018](https://www.biorxiv.org/content/10.1101/258566v2), y se añade el nº total de lecturas en forma de variable latente para mitigar el efecto negativo en los resultados de tener librerías/muestras con distintas profundidades de secuenciado. 

Para datos dispersos como es scATAC-seq, es necesario ajustar el parámetro `min.pct` del comando `FindMarkers()` con valores más bajos, ya que el valor que usa por defecto (0.1) está pensado para datos de scRNA-seq. En nuestro caso detectaremos regiones diferencialmente accesibles entre las neuronas intratelencefálicas de capas corticales 2/3 y las neuronas de capas 4-6 (siendo todas ellas neuronas excitatorias):

```{r}
# Volvemos a trabajar con picos en vez de actividad génica
DefaultAssay(MB_Signac) <- "peaks"

# `L5 IT` está en tipos celulares predichos
Idents(MB_Signac) <- MB_Signac$predicted.id
da_peaks <- FindMarkers(
  object = MB_Signac,
  ident.1 = c("L2/3 IT"), 
  ident.2 = c("L4", "L5 IT", "L6 IT"), # IT = IntraTelencefálico; L = Layer
  min.pct = 0.05,  # 0.1 para scRNA-seq; 0.05 para scATAC-seq
  test.use = "LR",
  latent.vars = "peak_region_fragments"
)

head(da_peaks)
```


<br>

Visualizamos los resultados del test de accesibilidad diferencial en un violinplot y sobre la proyección del UMAP:

```{r,fig.width = 8}
plot1 <- VlnPlot(object = MB_Signac, features = rownames(da_peaks)[1], 
                 pt.size = 0.1, idents = c("L4","L5 IT","L2/3 IT", "L6 IT")) + 
         ylab("Insertion/Aperture level") + NoLegend()

plot2 <- FeaturePlot(object = MB_Signac, features = rownames(da_peaks)[1], 
                     pt.size = 0.1, max.cutoff = "q95")

plot1 | plot2
```

<br>

En vista de los resultados podemos ver que la región del cromosoma 4 comprendida entre las bases 86.523.678-86.525.285 está diferencialmente abierta (i.e. expresada) en las neuronas piramidales de capas corticales 2/3 respecto de las de capas 4-6. Dicha región abarca el gen Fam154a/Saxo1:

```{r}
CoveragePlot(object = MB_Signac, region = "chr4-86523678-86525285",
             extend.upstream = 1000, extend.downstream = 1000,
             ncol = 1, idents = c("L2/3 IT", "L4", "L5 IT", "L6 IT"))
```


<br>

Puede ser difícil interpretar las coordenadas de los picos de integración de transposones (al fin y al cabo, no es común saberse de memoria las bases exactas que ocupa un gen). Por suerte, `Signac` cuenta con una utilidad para descubrir genes cercanos a (o que mapeen en) las regiones cromosómicas que le indiquemos. Esta utilidad es el comando `ClosestFeature()`. Con dicho comando podemos comprobar que, efectivamente, el gen más cercano a la región chr4-86523678-86525285 es Fam154a/Saxo1:

```{r}
# Regiones cromosómicas abiertas con un log2FC > |0.25| en neuronas de capas
# L2/3 y L4-5
open_l23 <- rownames(da_peaks[da_peaks$avg_log2FC > 0.25, ])
open_l456 <- rownames(da_peaks[da_peaks$avg_log2FC < -0.25, ])

# Genes que mapean en dichas regiones
closest_l23 <- ClosestFeature(MB_Signac, open_l23)
closest_l456 <- ClosestFeature(MB_Signac, open_l456)
head(closest_l23)
head(closest_l456)
```






***

<br>

# Visualizar regiones cromosómicas


Tal como veíamos 2 párrafos antes, podemos visualizar el nº de integraciones de la Tn5 en el genoma mediante la función `CoveragePlot()`. Esta función acepta loci tanto en formato coordenadas cromosómicas (_i.e._ chr4-86523678-86525285) como en formato nombre del gen (_i.e._ Neurod6). Cada tipo celular presente en el gráfico resultante muestra el nº medio de sitios de integración en todas las células del tipo en cuestión. También podemos graficar clusters o cualquier otro metadato, en lugar de los tipos celulares:

```{r}
# Establecemos el orden en el gráfico de las células a mostrar:
levels(MB_Signac) <- c("L2/3 IT", "L4", "L5 IT", "L5 PT", "L6b", "L6 CT", "L6 IT", "NP", "Sst" ,"Pvalb" ,"Vip" ,"Lamp5" , "Oligo", "Astro", "Endo", "VLMC", "Macrophage", "Sncg", "Peri")

# Coordenadas cromosómicas
CoveragePlot(
  object = MB_Signac,
  region = "chr4-86523678-86525285",
  extend.upstream = 1000,
  extend.downstream = 1000,
  ncol = 1)
```

```{r, fig.height =  10}
# Nombres de genes
CoveragePlot(
  object = MB_Signac,
  region = c("Neurod6", "Gad2"),
  extend.upstream = 1000,
  extend.downstream = 1000,
  ncol = 1,
  idents = levels(MB_Signac)[1:5])
```

```{r}
# Apertura media en todas las células, se aprecia la caja TATA del gen Sst
CoveragePlot(
  object = MB_Signac,
  region = "Sst",
  extend.upstream = 1000,
  extend.downstream = 1000,
  ncol = 1,
  group.by = "orig.ident")
```


<br>

También se puede generar mediante la función `CoverageBrowser()` una versión interactiva de estos gráficos en la cual se puede explorar el genoma y ajustar al vuelo los parámetros de graficado. El botón “_Save plot_” guarda el gráfico en un objeto `ggplot` y se carga en el ambiente al cerrar la página interactiva.





***

<br>

# _Addendum_: Qué hacer si el dataset no se generó con CellRanger


The CellRanger software from 10x Genomics generates several useful QC metrics per-cell, as well as a peak/cell matrix and an indexed fragments file. In the above vignette, we utilize the CellRanger outputs, but provide alternative functions in Signac for many of the same purposes here.


## Generating a peak/cell or bin/cell matrix

The FeatureMatrix function can be used to generate a count matrix containing any set of genomic ranges in its rows. These regions could be a set of peaks, or bins that span the entire genome.

```{r, eval = F}
# not run
# peak_ranges should be a set of genomic ranges spanning the set of peaks to be quantified per cell
peak_matrix <- FeatureMatrix(
  fragments = Fragments(pbmc),
  features = peak_ranges
)
```


For convenience, we also include a GenomeBinMatrix() function that will generate a set of genomic ranges spanning the entire genome for you, and run FeatureMatrix() internally to produce a genome bin/cell matrix.

```{r, eval = F}
# not run
bin_matrix <- GenomeBinMatrix(
  fragments = Fragments(pbmc),
  genome = seqlengths(pbmc),
  binsize = 5000
)
```


## Counting fraction of reads in peaks

The function FRiP() will count the fraction of reads in peaks for each cell, given a peak/cell assay and a bin/cell assay. Note that this can be run on a subset of the genome, so that a bin/cell assay does not need to be computed for the whole genome. This will return a Seurat object will metadata added corresponding to the fraction of reads in peaks for each cell.

```{r, eval = F}
# not run
total_fragments <- CountFragments("'/home/stuartt/github/chrom/vignette_data/atac_v1_pbmc_10k_fragments.tsv.gz'")
pbmc$fragments <- total_fragments[colnames(pbmc), "frequency_count"]

pbmc <- FRiP(
  object = pbmc,
  assay = 'peaks',
  total.fragments = 'fragments'
)
```



## Counting fragments in genome blacklist regions

The ratio of reads in genomic blacklist regions, that are known to artifactually accumulate reads in genome sequencing assays, can be diagnostic of low-quality cells. We provide blacklist region coordinates for several genomes (hg19, hg38, mm9, mm10, ce10, ce11, dm3, dm6) in the Signac package for convenience. These regions were provided by the ENCODE consortium, and we encourage users to cite their paper if you use the regions in your analysis. The FractionCountsInRegion() function can be used to calculate the fraction of all counts within a given set of regions per cell. We can use this function and the blacklist regions to find the fraction of blacklist counts per cell.

```{r, eval = F}
# not run
pbmc$blacklist_fraction <- FractionCountsInRegion(
  object = pbmc, 
  assay = 'peaks',
  regions = blacklist_hg19
)
```






***

<br>

# Bibliografía

* Stuart _et al._ Multimodal single-cell chromatin analysis with Signac. bioRxiv (2020).

* ENCODE portal (PMID: 29126249; PMCID: PMC5753278)

* Srivatsan, Sanjay & McFaline-Figueroa, José & Ramani, Vijay & Saunders, Lauren & Cao, Junyue & Packer, Jonathan & Pliner, Hannah & Jackson, Dana & Daza, Riza & Christiansen, Lena & Zhang, Fan & Steemers, Frank & Shendure, Jay & Trapnell, Cole. (2019). Massively multiplex chemical transcriptomics at single cell resolution. Science. 367. eaax6234. 10.1126/science.aax6234.

* Hannah A. Pliner, Jonathan S. Packer, José L. McFaline-Figueroa, Darren A. Cusanovich, Riza M. Daza, Sanjay Srivatsan, Xiaojie Qiu, Dana Jackson, Anna Minkina, Andrew C. Adey, Frank J. Steemers, Jay Shendure, Cole Trapnell. Molecular Cell 71, 1–14 2018

* Stuart T, Butler A, Hoffman P, Hafemeister C, Papalexi E, Mauck WM 3rd, Hao Y, Stoeckius M, Smibert P, Satija R. Comprehensive Integration of Single-Cell Data. Cell. 2019 Jun 13;177(7):1888-1902.e21. doi: 10.1016/j.cell.2019.05.031. Epub 2019 Jun 6. PMID: 31178118; PMCID: PMC6687398.

* Billeh YN, Cai B, Gratiy SL, Dai K, Iyer R, Gouwens NW, Abbasi-Asl R, Jia X, Siegle JH, Olsen SR, Koch C, Mihalas S, Arkhipov A. Systematic Integration of Structural and Functional Data into Multi-scale Models of Mouse Primary Visual Cortex. Neuron. 2020 May 6;106(3):388-403.e18. doi: 10.1016/j.neuron.2020.01.040. Epub 2020 Mar 5. PMID: 32142648.

* Ntranos, V., Yi, L., Melsted, P. et al. A discriminative learning approach to differential expression analysis for single-cell RNA-seq. Nat Methods 16, 163–166 (2019). https://doi.org/10.1038/s41592-018-0303-9



***

<br>

# sessionInfo()

<details>

<summary> __Click para mostrar__ </summary>

```{r, echo = F}
sessionInfo()
```

</details>