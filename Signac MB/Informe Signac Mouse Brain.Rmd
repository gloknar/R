---
title: "Análisis de datos scATAC-seq en Signac: 2700 PBMC"
author: "Adam Casas"
date: 'Compilado: `r format(Sys.Date(), "%d de %B del %Y")`'
output: 
  html_document:
    df_print: paged
    highlight: kate
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_float: yes
---

```{r configuracion_inicial, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = F,
                      warning = F)
set.seed(1)
##################################################
#######        Encoded in UTF-8        ###########
##################################################
```

```{r Paralelizado protocolo, echo = F}
# Establecemos el límite de tamaño que puede usar `future` en 2 GBs dado que de
# lo contrario superamos el límite por defecto de 500 MBs al trabajar con objetos
# tan grandes
library("future")
plan(strategy = "multisession", workers = 4)
options(future.globals.maxSize = 2 * 1024^3)
```


***

# Instalación

Instalamos `Signac` en R versión 4.1:

```{r, eval = F}
BiocManager::install("Rsamtools")
install.packages("Signac")
```



***

<br>

# Introducción

`Signac` (Stuart _et al._, 2020) es una extensión del famoso paquete `Seurat` para explorar, analizar e interpretar datasets de scATAC-seq. ATAC-seq (y su variante de célula única) es, por decirlo de alguna manera, la sucesora espiritural de técnicas de secuenciacón como ChIP-seq y RRBS-Seq. Si en dichas técnicas se estudia el estado epigenético de las células/tejidos de interés, cierto es que se debe tener un conocimiento previo de cómo actúan los mecanismos epigenéticos del organismo en cuestión para poder sacarles el mayor rendimiento. __ATAC-seq__, por otro lado, evade dicha imposición al estudiar directamente la __accesibilidad de la cromatina__ a la transposasa hiperactiva Tn5 de manera "agnóstica" (sin necesidad de conocer _a priori_ los mecanismos epigenéticos subyacentes).


En este informe vamos a presentar `Signac` mediante el análisis del ya conocido dataset 2700 PBMC de [10x Genomics](https://www.10xgenomics.com/). Para ello debemos descargar primero los siguientes archivos (deberás descargarlos e instalarlos, pues pesan demasiado como para subirlos a GitHub): 

```{r, eval = F}
# El archivo con los datos crudos del ATAC-seq
download.file("https://cf.10xgenomics.com/samples/cell-atac/1.0.1/atac_v1_pbmc_10k/atac_v1_pbmc_10k_filtered_peak_bc_matrix.h5", destfile = "./archivos_accesorios/atac_v1_pbmc_10k_filtered_peak_bc_matrix.h5")

# Sus metadatos
download.file("https://cf.10xgenomics.com/samples/cell-atac/1.0.1/atac_v1_pbmc_10k/atac_v1_pbmc_10k_singlecell.csv", destfile = "./archivos_accesorios/atac_v1_pbmc_10k_singlecell.csv")

# El archivo de los fragmentos
download.file("https://cf.10xgenomics.com/samples/cell-atac/1.0.1/atac_v1_pbmc_10k/atac_v1_pbmc_10k_fragments.tsv.gz", destfile = "./archivos_accesorios/atac_v1_pbmc_10k_fragments.tsv.gz")

# El archivo con el índice de los fragmentos
download.file("https://cf.10xgenomics.com/samples/cell-atac/1.0.1/atac_v1_pbmc_10k/atac_v1_pbmc_10k_fragments.tsv.gz.tbi", destfile = "./archivos_accesorios/atac_v1_pbmc_10k_fragments.tsv.gz.tbi")
```



Ahora cargamos las librerías que vamos a usar:

```{r, message=F, warning=F}
library(Signac)
library(Seurat)
library(GenomeInfoDb)
library(EnsDb.Mmusculus.v79)
library(ggplot2)
library(patchwork)
set.seed(1234)
```




***

<br>

# Preprocesado

`Signac` requiere dos archivos adicionales generados por el software _CellRanger_ para poder preprocesar datos de ATAC-Seq:

* __Peak/Cell matrix.__ La matriz de picos o células es similar a la matriz de expresión génica de dimensiones _genes_ x _células_ usada en scRNA-Seq. En ATAC-Seq la matriz es de _regiones cromosómicas_ x _células_. Cada valor de la matriz es el nº de sitios de integración de Tn5 en cada célula que mapean en dichas regiones o _peaks_.


* __Fragment file.__ Representa la lista completa de fragmentos únicos (= lecturas) detectados en todas las células y es por tanto un archivo MUY pesado. Al ser tan pesado, se guarda en el disco duro en lugar de la RAM y a consecuencia manipularlo es un proceso lento. Su ventaja es que contiene todos los sitios de integración de Tn5 en cada célula.



Ya que `Signac` es una extensión de `Seurat`, vamos a trabajar con un objeto `Seurat` generado a partir de la __matriz de picos/célula__, sus __metadatos__ creados en `cellranger-atac` y el __archivo de fragmentos__.


```{r}
# Cargamos y visualizamos las 6 primeras filas de la matriz de ATAC_Seq en el objeto `matriz_picos_ATAC`:
matriz_picos_ATAC <- Read10X_h5("E:/Git/R/Signac MB/archivos_accesorios/atac_v1_adult_brain_fresh_5k_filtered_peak_bc_matrix.h5")
matriz_picos_ATAC[c(1:5), c(1:5)]

# En la matriz de picos/células, las filas son regiones cromosómicas y las
# columnas son células. Mide el grado de apertura de la cromatina en las
# regiones cromosómicas (nº de transposasas detectadas en dicha región para la
# célula de la columna)


# METADATOS
metadatos <- read.csv(
  file = "E:/Git/R/Signac MB/archivos_accesorios/atac_v1_adult_brain_fresh_5k_singlecell.csv",
  header = TRUE,
  row.names = 1)

metadatos[c(1:5), c(1:5)]
dim(metadatos)
summary(metadatos)

hist(x = metadatos$peak_region_fragments, main = "Distribución de los peak region fragments", col = "turquoise")
boxplot(x= metadatos$peak_region_fragments)

# OBJETO TIPO `ChromatinAssay`
ensayo_ATAC_Seq <- CreateChromatinAssay(
  counts = matriz_picos_ATAC,
  sep = c(":", "-"),
  genome = "mm10",
  fragments = "E:/Git/R/Signac MB/archivos_accesorios/atac_v1_adult_brain_fresh_5k_fragments.tsv.gz",
  min.cells = 1)






# OBJETO TIPO `seurat`
pbmc_Signac <- CreateSeuratObject(
  counts = ensayo_ATAC_Seq,
  assay = "peaks",
  project = "ATAC",
  meta.data = metadatos)



pbmc_Signac
pbmc_Signac[["peaks"]]
```


Los datos de la secuenciación ATAC se guardan en un objeto de tipo `ChromatinAssay`, el cual se caracteriza por presentar bolsillos para almacenar información adicional sobre motifs, anotaciones de los genes e información del genoma. A partir de dicho objeto creamos el principal objeto `seurat` donde realizaremos los análisis.  

Podemos usar la función `granges()` en un objeto de tipo `seurat` que tenga como experimento activo uno de tipo `ChromatinAssay` para observar las regiones cromosómicas asociada a cada feature (gen?) del objeto. Para más información sobre la clase `ChromatinAssay`, consulte la [viñeta de interacción con objetos](https://satijalab.org/signac/articles/data_structures.html).


```{r}
# Exploración del ensayo/experimento de ATAC-Seq
ensayo_ATAC_Seq[1:5, 1:5]
dim(ensayo_ATAC_Seq) # Las columnas son las células secuenciadas.. 8728 células

class(ensayo_ATAC_Seq)
granges(pbmc_Signac)
```



También podemos añadir al objeto `pbmc_Signac` las anotaciones del genoma humano para que ciertos comandos puedan hacer uso de dicha información. 

```{r, warning = F}
# extract gene annotations from EnsDb
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Mmusculus.v79)

# change to UCSC style since the data was mapped to hg19
seqlevelsStyle(annotations) <- "UCSC"
genome(annotations) <- "mm10"

# add the gene information to the object
Annotation(pbmc_Signac) <- annotations
Annotation(pbmc_Signac)
```

```{r, echo = F, eval = F}
seqinfo(pbmc_Signac)
pbmc_Signac@meta.data
annotations@elementMetadata
```





***

<br>

# Métricas de calidad (QC)


Ahora podemos comenzar con el control de calidad. Los creadores de `Signac` recomiendan prestar atención a las siguientes métricas: 

 * __Nucleosome banding pattern__: El histograma de los tamaños de los fragmentos de ADN (de secuencias paired-end, ojo) debe exhibir un marcado patrón de bandeo de nucleosomas correspondiente a la longitud del ADN enrollado alrededor de un único nucleosoma. Esta métrica se calcula mediante la siguiente ecuación:
 
$$nucleosome\ signal = \frac{fragmentos\_mononucleosomales}{fragmentos\_sin\_nucleosomas}$$

 * __Transcriptional start site (TSS) enrichment score__. El [proyecto ENCODE](https://www.encodeproject.org/data-standards/terms/) define el _TSS enrichment score_ como el ratio de fragmentos centrados en el TSS vs fragmentos flanqueantes al TSS. Los experimentos de ATAC-Seq mal hechos suelen tener un _TSS enrichment score_ bajo. Esta métrica se calcula para cada célula con el comando `TSSEnrichment()` y se almacena en los metadatos en la columna `TSS.enrichment`.

 * __Número total de fragmentos (= lecturas) en picos__: Las células con muy pocas lecturas se han secuenciado con poca profundidad, mientras que las células con muchas lecturas podrían ser _doublets_ (dos células secuenciadas como una), agregados de núcleos u otro tipo de artefactos. Por consiguiente se deben eliminar todas las células con valores extremos de lecturas en picos.

 * __Ratio de lecturas en picos__: Representa el porcentaje de fragmentos (_i.e._ regiones cromosómicas) que caen en picos. Las células con un ratio bajo (<15~20%) suelen ser células mal secuenciadas o artefactos técnicos (ruido) y por tanto se deberían eliminar. Tenga en cuenta que el umbral de rechazo de células depende del set de picos usado.

 * __Ratio de lecturas en regiones genómicas ruidosas (_blacklists_)__. El proyecto ENCODE también ha publicado para el genoma humano (hg19 y GRCh38) y otros una [lista negra](https://github.com/Boyle-Lab/Blacklist) de regiones cromosómicas que consiste en un listado de las lecturas normalmente asociadas a ruido técnico. Las células con un porcentaje elevado lecturas que mapeen a dichos loci suelen ser ruido y deben eliminarse. Las listas negras de ENCODE actualmente disponibles en `Signac` son para genoma humano(hg19 y GRCh38), ratón (mm10), Drosophila (dm3), y _C. elegans_ (ce10).

Téngase en cuenta que las métricas `Total number of fragments in peaks`, `Fraction of fragments in peaks` y `Ratio reads in genomic blacklist regions` pueden obtenerse del output de `CellRanger` de 10X Genomics. También es posible analizar datasets no provenientes de 10X Genomics gracias a las utilidades que incorpora `Signac`.


```{r}
pbmc_Signac <- NucleosomeSignal(object = pbmc_Signac)
```



```{r}
pbmc_Signac$nucleosome_group <- ifelse(pbmc_Signac$nucleosome_signal > 4, 'NS > 4', 'NS < 4')
FragmentHistogram(object = pbmc_Signac, group.by = 'nucleosome_group', region = 'chr1-1-10000000')
```



```{r}
pbmc_Signac <- TSSEnrichment(pbmc_Signac, fast = F) # Si usas el argumento fast = T, no puede ejecutar el TSSPlot, imagino que dihco argumento omite la matriz necesaria para dicho comando 
```


```{r}
pbmc_Signac$high.tss <- ifelse(pbmc_Signac$TSS.enrichment > 2, 'High', 'Low')
TSSPlot(pbmc_Signac, group.by = 'high.tss') + NoLegend()
```




```{r}
# DefaultAssay(pbmc_Signac) # el Assay es el correcto: "peaks"
# Calculamos el nucleosome signal score por célula
pbmc_Signac <- NucleosomeSignal(pbmc_Signac)

# Calculamos el TSS enrichment score por célula
# pbmc_Signac <- TSSEnrichment(pbmc_Signac)                                                          # PURGE ME: No funciona
# https://www.encodeproject.org/atac-seq/#standards Para interpretar los valores de TSS

# Calculamos el ratio de lecturas en picos y el ratio de lecturas que caen en
# regiones ruidosas
pbmc_Signac$pct_reads_in_peaks <- pbmc_Signac$peak_region_fragments / pbmc_Signac$passed_filters * 100
pbmc_Signac$blacklist_ratio <- pbmc_Signac$blacklist_region_fragments / pbmc_Signac$peak_region_fragments
```


Podemos graficar el enriquecimiento de TSS e 

We can inspect the TSS enrichment scores by grouping the cells based on the score and plotting the accessibility signal over all TSS sites. Setting the fast=TRUE option in TSSEnrichment() will only compute the TSS enrichment score without storing the entire cell by position matrix of Tn5 insertion frequency for each cell, and can save memory. However, setting fast=TRUE will not allow downstream plotting of the TSS enrichment signal for different groups of cells using the TSSPlot() function, shown here:

```{r, eval = F}
pbmc_Signac$high.tss <- ifelse(pbmc_Signac$TSS.enrichment > 2, 'High', 'Low')
TSSPlot(pbmc_Signac, group.by = "high.tss") + NoLegend()
```



```{r, eval = F}
pbmc_Signac$nucleosome_group <- ifelse(pbmc_Signac$nucleosome_signal > 4, "NS > 4", "NS < 4")
FragmentHistogram(pbmc_Signac, group.by = "nucleosome_group")
```




```{r}
VlnPlot(
  object = pbmc_Signac,
  features = c("pct_reads_in_peaks", "peak_region_fragments",
               "TSS.enrichment", "blacklist_ratio", "nucleosome_signal"),
  pt.size = 0.1,
  ncol = 5
)
```




```{r, eval = F}
pbmc_Signac <- subset(
  x = pbmc_Signac,
  subset = peak_region_fragments > 3000 &
    peak_region_fragments < 20000 &
    pct_reads_in_peaks > 15 &
    blacklist_ratio < 0.05 &
    nucleosome_signal < 4 &
    TSS.enrichment > 2
)

pbmc_Signac
```


***

<br>

## Normalization and linear dimensional reduction


```{r}
pbmc_Signac <- RunTFIDF(pbmc_Signac)
pbmc_Signac <- FindTopFeatures(pbmc_Signac, min.cutoff = 'q0')
pbmc_Signac <- RunSVD(pbmc_Signac)
```


```{r}
DepthCor(pbmc_Signac)
```


***

<br>

# Non-linear dimension reduction and clustering


```{r}
pbmc_Signac <- RunUMAP(pbmc_Signac, reduction = "lsi", dims = 2:30)
pbmc_Signac <- FindNeighbors(pbmc_Signac, reduction = "lsi", dims = 2:30)
pbmc_Signac <- FindClusters(pbmc_Signac, verbose = FALSE, algorithm = 3) # Desactiva el paralelizado de `future` para evitar errores aleatorios
DimPlot(pbmc_Signac, label = TRUE) + NoLegend()
```




```{r}
cov_plot <- CoveragePlot(
  object = pbmc_Signac,
  region = "chr2-87011729-87035519",
  annotation = FALSE,
  peaks = FALSE
)

cov_plot
```


***

<br>

# Create a gene activity matrix








***

<br>

# Integrating with scRNA-seq data


[PH]




***

<br>

# Find differentially accessible peaks between clusters



[PH]








***

<br>

# Plotting genomic regions


placeholder





***

<br>

# Bibliografía

* Stuart _et al._ Multimodal single-cell chromatin analysis with Signac. bioRxiv (2020).

* [PH]

* [PH]

* [PH]




***

<br>

# sessionInfo()

<details>

<summary> __Click para mostrar__ </summary>

```{r, echo = F}
sessionInfo()
```

</details>